<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="2021年蓝桥杯准备笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="蓝桥杯">
<meta property="og:url" content="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/index.html">
<meta property="og:site_name" content="lagomerH">
<meta property="og:description" content="2021年蓝桥杯准备笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210319105542812.png">
<meta property="og:image" content="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210319111251977.png">
<meta property="og:image" content="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/v2-5d60fe34ae244a296cd3562617facea7_r.png">
<meta property="og:image" content="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210319175422751.png">
<meta property="og:image" content="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210320113319787.png">
<meta property="og:image" content="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/QuickSort2.png">
<meta property="og:image" content="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/quick_sort_partition_animation.gif">
<meta property="article:published_time" content="2021-03-05T04:13:31.000Z">
<meta property="article:modified_time" content="2021-03-23T14:41:40.449Z">
<meta property="article:author" content="Jiahui Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210319105542812.png">


<link rel="canonical" href="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>蓝桥杯 | lagomerH</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/lagomerH" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">lagomerH</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">心有猛虎 | 细嗅蔷薇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#last"><span class="nav-number">1.</span> <span class="nav-text">last</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">1.3.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%AC%94%E8%AE%B0"><span class="nav-number">1.4.</span> <span class="nav-text">C++笔记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88"><span class="nav-number">1.5.</span> <span class="nav-text">字符串和字符数组字符指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.6.</span> <span class="nav-text">C++遍历字符串的三种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E7%9A%84%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95"><span class="nav-number">1.7.</span> <span class="nav-text">string的详细用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.8.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.9.</span> <span class="nav-text">与字符数组的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.10.</span> <span class="nav-text">string对象的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E4%BD%BF%E7%94%A8"><span class="nav-number">1.11.</span> <span class="nav-text">与字符串字面使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E5%87%BD%E6%95%B0"><span class="nav-number">1.12.</span> <span class="nav-text">string函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6"><span class="nav-number">1.13.</span> <span class="nav-text">插入字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%8F%90%E5%8F%96%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.14.</span> <span class="nav-text">从提取子字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E5%88%B0int%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.15.</span> <span class="nav-text">string到int的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E6%97%A5%E5%87%BD%E6%95%B0"><span class="nav-number">1.16.</span> <span class="nav-text">每日函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E8%92%9C%E5%AE%A2"><span class="nav-number">1.17.</span> <span class="nav-text">计蒜客</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8sort%E8%BF%9B%E8%A1%8C%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.17.1.</span> <span class="nav-text">使用sort进行数组排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.17.2.</span> <span class="nav-text">结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.18.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8STL%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.19.</span> <span class="nav-text">常用STL的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.19.1.</span> <span class="nav-text">动态数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.19.2.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-number">1.19.3.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%80%92%E5%BD%92"><span class="nav-number">1.19.4.</span> <span class="nav-text">栈和递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92-%E5%BD%92"><span class="nav-number">1.20.</span> <span class="nav-text">递 归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95"><span class="nav-number">1.21.</span> <span class="nav-text">二分查找的递归解法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A0"><span class="nav-number">1.22.</span> <span class="nav-text">深度优先搜素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%B7%E9%A2%98"><span class="nav-number">1.23.</span> <span class="nav-text">刷题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E8%92%9C%E5%AE%A2%E5%88%B7%E9%A2%98"><span class="nav-number">1.24.</span> <span class="nav-text">计蒜客刷题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E8%AE%AD"><span class="nav-number">2.</span> <span class="nav-text">集训</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%86%E5%B9%B4%E7%9C%9F%E9%A2%98"><span class="nav-number">2.1.</span> <span class="nav-text">历年真题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019B%E7%BB%84%E7%9C%81%E8%B5%9B"><span class="nav-number">2.1.1.</span> <span class="nav-text">2019B组省赛</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E9%98%9F"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">组队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">I后缀表达式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="nav-number">3.</span> <span class="nav-text">语言基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.1.</span> <span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.1.1.</span> <span class="nav-text">函数模板</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%AF%87"><span class="nav-number">4.</span> <span class="nav-text">算法篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.1.</span> <span class="nav-text">树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BC%96%E5%8F%B7"><span class="nav-number">4.1.1.</span> <span class="nav-text">二叉树编号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">4.1.2.</span> <span class="nav-text">二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-bfs"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">二叉树宽度优先遍历 bfs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-dfs"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">二叉树的深度优先遍历 dfs</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">4.2.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8-bfs-%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">4.2.1.</span> <span class="nav-text">用 bfs 求最短路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">波兰表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97"><span class="nav-number">4.3.1.</span> <span class="nav-text">计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.2.</span> <span class="nav-text">调度场算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">4.4.</span> <span class="nav-text">文件处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fropen"><span class="nav-number">4.4.1.</span> <span class="nav-text">fropen</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%AD%A5"><span class="nav-number">4.5.</span> <span class="nav-text">动态规划初步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">4.5.1.</span> <span class="nav-text">数字三角形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%98%B6%E6%AE%B5%E5%86%B3%E7%AD%96%E9%97%AE%E9%A2%98"><span class="nav-number">4.5.2.</span> <span class="nav-text">多阶段决策问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">0-1背包问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">4.5.3.</span> <span class="nav-text">问题分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MC%E7%94%9F%E5%AD%98%E4%B9%B0%E4%B8%9C%E8%A5%BF"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">MC生存买东西</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95"><span class="nav-number">4.6.</span> <span class="nav-text">其他算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">4.6.1.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9"><span class="nav-number">4.6.2.</span> <span class="nav-text">线性时间选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95"><span class="nav-number">4.7.</span> <span class="nav-text">分治法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95"><span class="nav-number">4.7.1.</span> <span class="nav-text">一般方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%83"><span class="nav-number">4.7.2.</span> <span class="nav-text">求最大最小元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">4.7.3.</span> <span class="nav-text">二分搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E8%A7%A3"><span class="nav-number">4.7.3.1.</span> <span class="nav-text">用分治法求解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E5%8D%8A%E6%90%9C%E7%B4%A2"><span class="nav-number">4.7.3.2.</span> <span class="nav-text">对半搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E5%88%A4%E5%AE%9A%E6%A0%91"><span class="nav-number">4.7.3.3.</span> <span class="nav-text">二叉判定树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="nav-number">4.7.4.</span> <span class="nav-text">排序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">4.7.4.1.</span> <span class="nav-text">合并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">4.7.4.2.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98"><span class="nav-number">4.7.5.</span> <span class="nav-text">选择问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AF%E7%89%B9%E6%8B%89%E6%A3%AE%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="nav-number">4.7.6.</span> <span class="nav-text">斯特拉森矩阵乘法</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiahui Wang"
      src="/images/avatar2.jpg">
  <p class="site-author-name" itemprop="name">Jiahui Wang</p>
  <div class="site-description" itemprop="description">若有恒，何必三更起五更眠；<br>最无益，莫过一日曝十日寒。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lagomerH" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lagomerH" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:76946112@qq.com" title="E-Mail → mailto:76946112@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.jpg">
      <meta itemprop="name" content="Jiahui Wang">
      <meta itemprop="description" content="若有恒，何必三更起五更眠；<br>最无益，莫过一日曝十日寒。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagomerH">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          蓝桥杯
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-05 12:13:31" itemprop="dateCreated datePublished" datetime="2021-03-05T12:13:31+08:00">2021-03-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-23 22:41:40" itemprop="dateModified" datetime="2021-03-23T22:41:40+08:00">2021-03-23</time>
      </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><em>2021年蓝桥杯准备笔记。</em><br><a id="more"></a></p>
<h1 id="last"><a href="#last" class="headerlink" title="last"></a>last</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>末尾以<code>\0</code>结束的字符型数组称为字符串。值得强调的是只有以<code>\0</code>结束的才算字符串，否则只能算字符数组。</p>
<p><strong>strcpy()</strong>函数：复制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;hellowlrld&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(name, str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name;</span><br></pre></td></tr></table></figure>
<p><strong>strcat</strong>函数：拼接</p>
<p><strong>strcmp()</strong>函数：比较，如果两个字符串完全相同返回0.从第一个字符开始逐字符比较ASCII码，返回第一个不相同字符ASCII码差值。</p>
<p><strong>strlen()</strong>函数；返回字符串长度</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位运算的奇巧淫技：</p>
<ul>
<li>判断奇偶性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x &amp; <span class="number">1</span> == <span class="number">1</span>; <span class="comment">//奇数：奇数二进制最低位必为1</span></span><br><span class="line">x &amp; <span class="number">1</span> == <span class="number">0</span>; <span class="comment">//偶数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取二进制位是1还是0：通过左移1的位置，原理同上</li>
<li>交换两个整型变量的值：做三次异或操作</li>
<li>不用判断语句求整数的绝对值</li>
<li>拓展：异或操作可以理解为不进位加法，相同为0不同为1</li>
</ul>
<p>问题：</p>
<ul>
<li>将1-1000这些个数放在一个1001个元素的数组中，只有唯一的一个元素重复。每个元素只能访问一次，设计一个算法找出这个数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方案<span class="number">1</span>：</span><br><span class="line"><span class="comment">// A ^ A == 0;</span></span><br><span class="line"><span class="comment">// B ^ 0 == B;  是1的位还为1是0的还为0</span></span><br><span class="line"><span class="comment">// A ^ B ^ C == A ^ C ^ B </span></span><br><span class="line"><span class="comment">//满足交换律：本质看同一位01的个数为奇数还是偶数</span></span><br><span class="line"><span class="number">1</span>^<span class="number">2</span>^...^<span class="number">1001</span> ^(<span class="number">1</span>^<span class="number">2</span>^..<span class="number">.1000</span>);</span><br><span class="line"></span><br><span class="line">方案<span class="number">2</span>；</span><br><span class="line">扫描技术法：开一个数组，用存数数组的元素作为该数组的下标，没出现一次便加一操作</span><br></pre></td></tr></table></figure>
<ul>
<li>输入一个整数，输出该数二进制中1的个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">设输入量为x</span><br><span class="line">方案<span class="number">1</span>：</span><br><span class="line">做&amp;运算并向左移动<span class="number">1</span>的位置</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    x &amp; i != <span class="number">0</span>; <span class="comment">//此时计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方案<span class="number">2</span>；右移x</span><br><span class="line"></span><br><span class="line">方案<span class="number">3</span>：经典：消掉<span class="number">1</span></span><br><span class="line">假设：<span class="number">100100</span>   将其进行<span class="number">-1</span>操作</span><br><span class="line">     -     <span class="number">1</span></span><br><span class="line">      <span class="number">100011</span>   变化由于借位原为<span class="number">1</span>的最低为变为<span class="number">0</span>其后<span class="number">0</span>变为<span class="number">1</span></span><br><span class="line"></span><br><span class="line">      <span class="number">100100</span></span><br><span class="line">    &amp; <span class="number">100011</span></span><br><span class="line">      <span class="number">100000</span>  继续进行<span class="number">-1</span>作与运算看做多少次后为<span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用一条语句判断一个整数是不是2的整数次方</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">观察<span class="number">2</span>的整数次方<span class="number">2</span>进制：<span class="number">1</span>，<span class="number">10</span>，<span class="number">100</span>，<span class="number">1000</span></span><br><span class="line">总结：只有一个<span class="number">1</span></span><br><span class="line">结合上题方案<span class="number">3</span>，有一个<span class="number">1</span>只能做一次减一作与操作</span><br><span class="line"><span class="keyword">if</span>(x&amp;(x<span class="number">-1</span>)==<span class="number">0</span>) <span class="comment">//便为2整数次方</span></span><br></pre></td></tr></table></figure>
<ul>
<li>整数二进制奇偶位呼唤</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  mmmmmmmm      mmmmmmmm</span><br><span class="line"> &amp;<span class="number">01010101</span>     &amp;<span class="number">10101010</span></span><br><span class="line">  0x0x0x0x      y0y0y0y0</span><br><span class="line">  偶数位        奇数位</span><br><span class="line">  x0x0x0x0      0y0y0y0y    分别左移右移</span><br><span class="line"></span><br><span class="line">  x0x0x0x0</span><br><span class="line">  0y0y0y0y  按位或或者按位异或操作</span><br><span class="line"></span><br><span class="line">拓展：<span class="number">0b1010</span> = <span class="number">0xa</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">0b1001</span>;</span><br><span class="line">  <span class="keyword">int</span> x = m &amp; <span class="number">0b01010101</span>;</span><br><span class="line">  <span class="keyword">int</span> y = m &amp; <span class="number">0b10101010</span>;</span><br><span class="line">  x = x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  y = y &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  m = x | y;</span><br><span class="line">  cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>0-1间浮点数的二进制表示：给定一个介于0-1之间的实数，打印它的二进制表示，如果该数无法用32位以内的二进制表示则打印error</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>二进制表示：除<span class="number">2</span>得七余<span class="number">1</span>，最低为填<span class="number">1</span>，同理次地位填<span class="number">1.</span>.<span class="number">.1111</span>从后往前填</span><br><span class="line"></span><br><span class="line"><span class="number">0.625</span>二进制表示：乘以<span class="number">2</span>得<span class="number">1.25</span> 在<span class="number">0.</span>后面填第一个<span class="number">1</span>，<span class="number">0.25</span>乘以<span class="number">2</span>得<span class="number">0.5</span>次高位填<span class="number">0.</span>... <span class="number">0.1010</span>。(<span class="number">0.05</span>,<span class="number">0.25</span>,<span class="number">0.125</span> .....)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数组中一个数只出现了1次，其他出现了k次找出出现了一次的数</p>
<p>两个相同的二进制数做不进位加法结果为0<br>十个相同的十进制数做不进位加法结果为0</p>
</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>栈溢出：无穷无尽递归<br>栈结构：后进先出<br>方法：找重复（规模更小，子问题）-找变化（变化的量作为参数）-找边界（出口）</p>
<p>问题：</p>
<ul>
<li>翻转字符串</li>
</ul>
<h2 id="C-笔记"><a href="#C-笔记" class="headerlink" title="C++笔记"></a>C++笔记</h2><h2 id="字符串和字符数组字符指针"><a href="#字符串和字符数组字符指针" class="headerlink" title="字符串和字符数组字符指针"></a>字符串和字符数组字符指针</h2><p>warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="string">&quot;abc&quot;</span>; <span class="comment">//warning</span></span><br><span class="line"><span class="keyword">char</span>* p = (<span class="keyword">char</span>*)<span class="string">&quot;abc&quot;</span>;  <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *p = <span class="string">&quot;abc&quot;</span>;　　<span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>原因解释：</p>
<p>学习c或者c++的时候都知道，如果在赋值操作的时候，等号两边的变量类型不一样，那么编译器会进行一种叫做 implicit conversion 的操作来使得变量可以被赋值。<br>在上面的表达式中等号右边的”abc”是一个不变常量，在c++中叫做string literal，type是const char *，而p则是一个char指针。如果强行赋值会发生什么呢？没错，就是将右边的常量强制类型转换成一个指针，结果就是我们在修改一个const常量。编译运行的结果会因编译器和操作系统共同决定，有的编译器会通过，有的会抛异常，就算过了也可能因为操作系统的敏感性而被杀掉。<br>像这种直接将string literal 赋值给指针的操作被开发者们认为是deprecated，只不过由于以前很多代码都有这种习惯，为了兼容，就保留下来了。</p>
<ul>
<li><p>字符串字面值常量使用双引号括起的字符序列，以’\0’为结束符。它存放在内存的常量区，自己有固定的首地址。如果将字符串字面值常量的首地址看作指针，那么这个指针是常指针常量。字符串指针本身只读而且其指向的内容（字符串的内容）只读。</p>
</li>
<li><p>处理字符串有两种方式：字符串指针和字符数组</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str_arr[] = <span class="string">&quot;What a nice day!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*str_pt = <span class="string">&quot;What a nice day!&quot;</span>;</span><br><span class="line"><span class="comment">//字符数组</span></span><br><span class="line">字符数组本身是可写的，也就是说在完成初始化后，可以对其进行再次赋值。同样的，也可以不对它进行初始化，而是先声明后赋值。</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str_arr&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str_arr;</span><br><span class="line">这样的语句都是合法的，前者直接输出字符串内容；后者对字符数组进行二次赋值，原值被覆盖。但是不能直接用字符串字面值常量对字符数组名赋值，也不能用字符串指针或字符数组名对字符数组名赋值。即字符数组名不可放在赋值号左边。</span><br><span class="line">对于上面那个字符数组str_arr[]，它的大小，即<span class="keyword">sizeof</span>(str_arr)的值是<span class="number">17</span>，也就是数组内所存字符串的大小（包括’\<span class="number">0</span>’结束符）。</span><br><span class="line">如果在头文件下，输出<span class="built_in">strlen</span>(str_arr)的值，那么会输出<span class="number">16</span>，也就是字符串内容的长度（不包括’\<span class="number">0</span>’结束符）。</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str_arr[i]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(str_arr+i)&lt;&lt;<span class="built_in">endl</span>; 、</span><br><span class="line">那么会输出字符数组中第i个字符。</span><br><span class="line">这个地方有个有趣的事情是，字符数组str_arr[]中的空格并没有被编译器识别为’\<span class="number">0</span>’结束符。那是因为，事实上’\<span class="number">0</span>’结束符的编码是<span class="number">0x00</span>，字符类型中并没有’\<span class="number">0</span>’这个字符，它不是空格，而是一个空字符。</span><br><span class="line">但是如果程序中使用</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str_arr;</span><br><span class="line">这样的语句输入一行带空格的字符串时，str_arr只能接收到第一个单词，这是因为输入流对象<span class="built_in">cin</span>把空格（ascii码为<span class="number">0x20</span>）约定为了输入结束的标志。</span><br><span class="line"></span><br><span class="line">这个时候就应该使用逐行输入的函数了。在C的环境下，使用gets()函数是可行且便利的，但是vs2017中C++剔除了gets()函数，这样我们使用<span class="built_in">cin</span>.getline()函数来输入带空格的字符串。在这个实例下，程序中可写：</span><br><span class="line"><span class="built_in">cin</span>.getline(str_arr,<span class="number">17</span>,’\n’);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串指针</span></span><br><span class="line">使用字符串指针处理的情况下，该字符串指针是是一个常指针。</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str_pt&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">是可行的，但是</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str_pt; </span><br><span class="line">是非法的（尽管编译器并不识别该错误，但是运行时会出错）。、</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*str_pt= <span class="string">&quot;What a nice day!&quot;</span>;</span><br><span class="line">str_pt = <span class="string">&quot;Yes,it is.&quot;</span>;</span><br><span class="line">这样的语句，也是可行的。常指针指向的地址可改（即可以通过给指针二次赋值指向不同地址），仅仅是不能通过指针修改其指向的内容。再加上，字符串字面值常量本身是一个常指针常量，它可以赋给字符串指针，那么同理，字符数组名这个指针常量赋给字符串指针合法也是理所当然的了。</span><br><span class="line">尽管字符串指针指向其所储存的字符串字面值常量的首地址，但是</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str_pt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">并不输出该地址，而是输出整个字符串。如果想要获得该地址，则需要这样写代码：</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="keyword">void</span>*)str_pt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str3[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str4[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str5 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str6 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (str1 == str2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (str4 == str3) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (str5 == str6) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (str1 == str6) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-遍历字符串的三种方式"><a href="#C-遍历字符串的三种方式" class="headerlink" title="C++遍历字符串的三种方式"></a>C++遍历字符串的三种方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一，常规下标方式</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt1</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            value *= <span class="number">10</span>;</span><br><span class="line">            value += str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; StrToInt1(<span class="string">&quot;1234&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二，迭代器</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt2</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//迭代器--在STL中，不破坏封装的情况下去访问容器</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span>::iterator it = str.begin();<span class="comment">//返回第一个位置的迭代器（类似于指针）</span></span><br><span class="line">        <span class="keyword">while</span> (it != str.end())<span class="comment">//str.end()是最后一个数据的下一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            value *= <span class="number">10</span>;</span><br><span class="line">            value += (*it - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;<span class="comment">//顺序表的迭代器</span></span><br><span class="line">        v.push_back(<span class="number">1</span>);</span><br><span class="line">        v.push_back(<span class="number">2</span>);</span><br><span class="line">        v.push_back(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vit = v.begin();</span><br><span class="line">        <span class="keyword">while</span> (vit != v.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *vit &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">            vit++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; StrToInt2(<span class="string">&quot;1234&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三，新式for循环</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt3</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str)<span class="comment">//ch依次取的是str里面的字符,直到取完为止</span></span><br><span class="line">        &#123;</span><br><span class="line">            value *= <span class="number">10</span>;</span><br><span class="line">            value += (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; StrToInt3(<span class="string">&quot;1234&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意新式for循环的底层是用for循环实现的</span></span><br></pre></td></tr></table></figure>
<h2 id="string的详细用法"><a href="#string的详细用法" class="headerlink" title="string的详细用法"></a>string的详细用法</h2><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str; <span class="comment">//生成一个空的字符串</span></span><br><span class="line"><span class="comment">//还有其他声明方法</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, stridx)</span></span>;  <span class="comment">// 将字符串str内&quot;始于位置stridx&quot;的部分当作字符串的初值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, stridx, <span class="built_in">strlen</span>)</span> </span>; <span class="comment">// 将字符串str内&quot;始于stridx且长度顶多strlen&quot;的部分作为字符串的初值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr)</span> </span>;  <span class="comment">// 将C字符串（以NULL结束）作为s的初值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(chars, chars_len)</span> </span>;  <span class="comment">// 将C字符串前chars_len个字符作为字符串s的初值。</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(num, ‘c’)</span> </span>;  <span class="comment">// 生成一个字符串，包含num个c字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(“value”)</span></span>;  <span class="built_in">string</span> s=“value”;  <span class="comment">// 将s初始化为一个字符串字面值副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(begin, end)</span></span>;  <span class="comment">// 以区间begin/end(不包含end)内的字符作为字符串s的初值</span></span><br><span class="line">s.~<span class="built_in">string</span>();  <span class="comment">//销毁所有字符，释放内存</span></span><br></pre></td></tr></table></figure>
<h2 id="与字符数组的比较"><a href="#与字符数组的比较" class="headerlink" title="与字符数组的比较"></a>与字符数组的比较</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">string</th>
<th style="text-align:center">字符阵列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">声明</td>
<td style="text-align:center">string s</td>
<td style="text-align:center">char s[100]</td>
</tr>
<tr>
<td style="text-align:center">取字符</td>
<td style="text-align:center">s[i]</td>
<td style="text-align:center">s[i]</td>
</tr>
<tr>
<td style="text-align:center">字符串长度</td>
<td style="text-align:center">s.length()；s.size()</td>
<td style="text-align:center">strlen(s) 不计 \0</td>
</tr>
<tr>
<td style="text-align:center">读取一行</td>
<td style="text-align:center">getline(cin,s)</td>
<td style="text-align:center">gets(s)</td>
</tr>
<tr>
<td style="text-align:center">设成某字符串</td>
<td style="text-align:center">s=”tgs”</td>
<td style="text-align:center">strcpy(s,”tgs”)</td>
</tr>
<tr>
<td style="text-align:center">字符串相加</td>
<td style="text-align:center">s+=”tgs”</td>
<td style="text-align:center">strcat(s,:”tgs”)</td>
</tr>
<tr>
<td style="text-align:center">字符串比较</td>
<td style="text-align:center">s==”tgs”</td>
<td style="text-align:center">strcmp(s,”tgs”)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="string对象的操作"><a href="#string对象的操作" class="headerlink" title="string对象的操作"></a>string对象的操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s.empty();  <span class="comment">// s为空串 返回true</span></span><br><span class="line">s.size();  <span class="comment">// 返回s中字符个数 类型应为：string::size_type</span></span><br><span class="line">s[n];  <span class="comment">// 从0开始相当于下标访问</span></span><br><span class="line">s1+s2;  <span class="comment">// 把s1和s2连接成新串 返回新串 </span></span><br><span class="line">s1=s2;  <span class="comment">// 把s1替换为s2的副本</span></span><br><span class="line">v1==v2;  <span class="comment">// 比较，相等返回true</span></span><br><span class="line"><span class="comment">//`!=, &lt;, &lt;=, &gt;, &gt;=`  惯有操作 任何一个大写字母都小于任意的小写字母</span></span><br></pre></td></tr></table></figure>
<h2 id="与字符串字面使用"><a href="#与字符串字面使用" class="headerlink" title="与字符串字面使用"></a>与字符串字面使用</h2><p>当进行string对象和字符串字面值混合连接操作时，+操作符的左右操作数必须至少有一个是string类型的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(“hello”)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s3=s1+”world”;  <span class="comment">//合法操作</span></span><br><span class="line"><span class="built_in">string</span> s4=”hello”+”world”;  <span class="comment">//非法操作：两个字符串字面值相加</span></span><br></pre></td></tr></table></figure>
<h2 id="string函数"><a href="#string函数" class="headerlink" title="string函数"></a>string函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) =, s.assign() <span class="comment">// 赋以新值 </span></span><br><span class="line"><span class="number">2</span>) swap() <span class="comment">// 交换两个字符串的内容 </span></span><br><span class="line"><span class="number">3</span>) +=, s.append(), s.push_back() <span class="comment">// 在尾部添加字符 </span></span><br><span class="line"><span class="number">4</span>) s.insert() <span class="comment">// 插入字符 </span></span><br><span class="line"><span class="number">5</span>) s.erase() <span class="comment">// 删除字符 </span></span><br><span class="line"><span class="number">6</span>) s.clear() <span class="comment">// 删除全部字符 </span></span><br><span class="line"><span class="number">7</span>) s.replace() <span class="comment">// 替换字符 </span></span><br><span class="line"><span class="number">8</span>) + <span class="comment">// 串联字符串 </span></span><br><span class="line"><span class="number">9</span>) ==,!=,&lt;,&lt;=,&gt;,&gt;=,compare() <span class="comment">// 比较字符串 </span></span><br><span class="line"><span class="number">10</span>) size(),length() <span class="comment">// 返回字符数量 </span></span><br><span class="line"><span class="number">11</span>) max_size() <span class="comment">// 返回字符的可能最大个数 </span></span><br><span class="line"><span class="number">12</span>) s.empty() <span class="comment">// 判断字符串是否为空 </span></span><br><span class="line"><span class="number">13</span>) s.capacity() <span class="comment">// 返回重新分配之前的字符容量 </span></span><br><span class="line"><span class="number">14</span>) reserve() <span class="comment">// 保留一定量内存以容纳一定数量的字符 </span></span><br><span class="line"><span class="number">15</span>) [ ], at() <span class="comment">// 存取单一字符 </span></span><br><span class="line"><span class="number">16</span>) &gt;&gt;,getline() <span class="comment">// 从stream读取某值 </span></span><br><span class="line"><span class="number">17</span>) &lt;&lt; <span class="comment">// 将谋值写入stream </span></span><br><span class="line"><span class="number">18</span>) copy() <span class="comment">// 将某值赋值为一个C_string </span></span><br><span class="line"><span class="number">19</span>) c_str() <span class="comment">// 返回一个指向正规C字符串(C_string)的指针 内容与本string串相同 有’\0’ </span></span><br><span class="line"><span class="number">20</span>) data() <span class="comment">// 将内容以字符数组形式返回 无’\0’ </span></span><br><span class="line"><span class="number">21</span>) s.substr() <span class="comment">// 返回某个子字符串 </span></span><br><span class="line"><span class="number">22</span>) begin() end() <span class="comment">// 提供类似STL的迭代器支持 </span></span><br><span class="line"><span class="number">23</span>) rbegin() rend() <span class="comment">// 逆向迭代器 </span></span><br><span class="line"><span class="number">24</span>) get_allocator() <span class="comment">// 返回配置器</span></span><br></pre></td></tr></table></figure>
<h2 id="插入字符"><a href="#插入字符" class="headerlink" title="插入字符"></a>插入字符</h2><p>也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。<br>s.insert(0,”my name”);<br>s.insert(1,str);<br>这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式。为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：<br>insert(size_type index, size_type num, chart c)和insert(iterator pos, size_type num, chart c)。<br>其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：<br>insert(0, 1, ‘j’);这时候第一个参数将转换成哪一个呢？<br>所以你必须这么写：insert((string::size_type)0, 1, ‘j’)！<br>第二种形式指出了使用迭代器安插字符的形式。</p>
<h2 id="从提取子字符串"><a href="#从提取子字符串" class="headerlink" title="从提取子字符串"></a>从提取子字符串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.substr(); <span class="comment">// 返回s的全部内容 </span></span><br><span class="line">s.substr(<span class="number">11</span>); <span class="comment">// 从索引11往后的子串 </span></span><br><span class="line">s.substr(<span class="number">5</span>,<span class="number">6</span>); <span class="comment">// 从索引5开始6个字符</span></span><br></pre></td></tr></table></figure>
<h2 id="string到int的转换"><a href="#string到int的转换" class="headerlink" title="string到int的转换"></a>string到int的转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">    str1=<span class="string">&quot;100&quot;</span>;</span><br><span class="line">    <span class="built_in">stringstream</span> stream;</span><br><span class="line">    stream&lt;&lt;str1;</span><br><span class="line">    stream&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="每日函数"><a href="#每日函数" class="headerlink" title="每日函数"></a>每日函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">append()：</span><br><span class="line">_itoa()：</span><br><span class="line"><span class="built_in">sprintf</span>()：</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="built_in">array</span>)/size(a[<span class="number">0</span>])：</span><br><span class="line"></span><br><span class="line">gets()</span><br><span class="line">fgets()</span><br><span class="line"></span><br><span class="line">round()</span><br><span class="line">unique()：注意使用时需要进行排序且其去重后长度</span><br><span class="line">swap()</span><br><span class="line"></span><br><span class="line">next_permutation()：全排列</span><br><span class="line"></span><br><span class="line">reverse()函数把<span class="built_in">list</span>所有元素倒转。</span><br><span class="line"><span class="built_in">string</span> str=<span class="string">&quot;hello world , hi&quot;</span>;</span><br><span class="line">reverse(str.begin(),str.end());<span class="comment">//str结果为 ih , dlrow olleh</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">reverse(v.begin(),v.end());<span class="comment">//容器v的值变为1,2,3,4,5</span></span><br></pre></td></tr></table></figure>
<h2 id="计蒜客"><a href="#计蒜客" class="headerlink" title="计蒜客"></a>计蒜客</h2><p>蔡基姆拉尔森计算公式：快速计算星期几</p>
<p>printf(%04d):4指输出的长度，0指不足的在前面补</p>
<p>空格处理方法：第一种知道多少输出先输出ans+空格，最后一个输出ans；第二种不知道多少个输出第一个输出ans，其后均输出空格+ans</p>
<p>string字符串可以使用&gt;&lt;进行大小比较</p>
<p>EPSILON = 1e-6</p>
<p>当使用字符串的时候不知道其大小范围最好使用string类型</p>
<p>当输入输出数据过大时cin,cout可能会超时，此时应该使用scanf和printf</p>
<p>string大写转小写<br>string ss;<br>for (int i = 0; i &lt; ss.size(); i++) {<br>    if (ss[i] &gt;= ‘A’ &amp;&amp; ss[i] &lt;= ‘Z’) {<br>        ss[i] = ‘a’ + (ss[i] - ‘A’);<br>    }<br>}</p>
<h3 id="使用sort进行数组排序"><a href="#使用sort进行数组排序" class="headerlink" title="使用sort进行数组排序"></a>使用sort进行数组排序</h3><p>sort可以进行数组排序，也可以排序自己定义的结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//!!!api文档中没有头文件</span></span><br><span class="line"><span class="comment">//arr开始元素到第5个元素</span></span><br><span class="line">sort(arr,arr+<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr[i]到arr[j]</span></span><br><span class="line">sort(arr+i,arr j+<span class="number">1</span>)  <span class="comment">//j =  下标+1等于此时是第几个</span></span><br><span class="line"><span class="comment">//默认从小到大排</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排</span></span><br><span class="line">sort(arr, arr+<span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="comment">//第三个参数是排序方法grater表示更大,int表示整数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序方案</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line"><span class="comment">//x大于y，x便在前面否则y在前面</span></span><br><span class="line"><span class="comment">//return什么就是什么成立</span></span><br><span class="line"><span class="comment">//此处不能有等于，容易出现错误</span></span><br><span class="line"><span class="comment">//等于的时候一定给false</span></span><br><span class="line">&#125;</span><br><span class="line">sort(arr, arr+i, cmp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体可以使用构造函数来进行初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    student() &#123;&#125; <span class="comment">//无参的默认构造函数，什么都不做</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表:赋值的更简单方法，只赋值不进行其他操作</span></span><br><span class="line">    student(<span class="built_in">string</span> n, <span class="keyword">int</span> s): name(n), score(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>根据提出的问题，列出该问题所有的可能解，并在逐一列出的过程中检查该解是否为问题的真正解。</p>
<p>解枚举范围必须是有穷的<br>检验条件是确定的</p>
<h2 id="常用STL的使用"><a href="#常用STL的使用" class="headerlink" title="常用STL的使用"></a>常用STL的使用</h2><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>当我们想要开一个数组，但不知道开多大合适。我们可以使用C++中的动态数组vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//必须有</span></span><br><span class="line"><span class="comment">//C++中直接构造和一个vector的语句：vector&lt;T&gt; vec</span></span><br><span class="line"><span class="comment">//定义了一个名为vec储存T类型数据的动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改  </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;   <span class="comment">//&#123;&#125;</span></span><br><span class="line">vec.push_back(<span class="number">1</span>);  <span class="comment">//&#123;1&#125;</span></span><br><span class="line">vec.push_back(<span class="number">12</span>;  <span class="comment">//&#123;1， 2&#125;</span></span><br><span class="line">vec[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vec[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素，只支持删除尾端：C++中使用pop_back()方法删除动态数组的最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空：只需要调用clear()函数</span></span><br><span class="line"><span class="comment">//clear()只是清空vector，并不会清空来内存，下面的方法可以清空开内存：</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;.swap(vec);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//高级用法</span></span><br><span class="line"><span class="comment">//用vector存储自定义的数据类型：比如说结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n)</span><br><span class="line"><span class="comment">//n表示初始的长度，1表示初始化元素均为1，如果不传入第二个元素初始化为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维动态数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec <span class="comment">//此处有一个空格防止与右移运算符发生冲突</span></span><br><span class="line"><span class="comment">//理解为：外vector中的类型为 vector&lt;int&gt;类型</span></span><br><span class="line"><span class="comment">//二维动态数组的每一维的长度都可以不一样，可以是任意形状的。</span></span><br><span class="line"><span class="comment">//借助构造函数我们可以快速构造一个n行m的动态数组，每个元素的初始值为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组有一种常见的错误写法</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    vec[i].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问的时候会出现访问非法内存，因为第一维的大小为0</span></span><br></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>由不重复数据组成的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;Y&gt; s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素 insert()</span></span><br><span class="line"><span class="comment">//集合中已经存在了某个元素，再次插入不会产生任何效果，集合中是不会有重复出现的元素的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素 erase()</span></span><br><span class="line"><span class="comment">//如果集合中不存在这个元素不会进行任何操作且不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断元素是否存在 count()</span></span><br><span class="line"><span class="comment">//如果集合中找到则返回1否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="comment">//C++可以通过迭代器访问集合中的每个元素，迭代器就好像一根手指指向set中的元素</span></span><br><span class="line"><span class="comment">//通过 * (解引用运算符) 操作可以获取迭代器指向的元素</span></span><br><span class="line"><span class="comment">//通过++或者)--操作让迭代器指向下一个或者上一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器的写法比较固定</span></span><br><span class="line"><span class="built_in">set</span>&lt;T&gt;::iterator it;</span><br><span class="line"><span class="comment">//就定义了指向set&lt;T&gt; 这种集合的迭代器</span></span><br><span class="line">begin()  <span class="comment">//返回容器中起始元素的迭代器</span></span><br><span class="line">end()    <span class="comment">//返回容器的尾后迭代器(已经超出集合范围，进行--操作可以得到最后一个元素)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：在C++中遍历set是从小到大的，也就是说set会帮我们排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作</span></span><br><span class="line">clear()</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 set 中插入删除和查找某个元素的时间复杂度都是 O(log n)，并且内部元素是有序的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配合结构体使用</span></span><br><span class="line"><span class="comment">//set是需要经过排序的，系统自带的数据类型有默认比较大小的规则</span></span><br><span class="line"><span class="comment">//而我们定义的结构体，系统不知道比较大小的规则</span></span><br><span class="line"><span class="comment">//我们可以采用运算符重载，重新定义小于号，告诉系统比较大小的规则</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == rhs.x) &#123;</span><br><span class="line">            <span class="keyword">return</span> y &lt; rhs.y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x &lt; rhs.x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rhs表示右操作数。因为该运算符重载定义在结构体内部，左操作数就是当前调用operator&lt;的对象</span></span><br><span class="line"><span class="comment">//不能漏掉最后的const。const函数表示不能对其数据成员进行修改操作</span></span><br><span class="line"><span class="comment">//并且const对象不能调用非const成员函数</span></span><br></pre></td></tr></table></figure>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射是指两个集合之间的元素的相互对应关系：姓名和班级。我们称姓名集合为<strong>关机键集合(key)</strong>，班级集合为<strong>值集合(value)</strong>。<br>在C++中我们常用的映射是map</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;T1, T2&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一对映射</span></span><br><span class="line"><span class="comment">//在C++中通过insert()函数向集合中插入一个新的映射，参数是一个 pair 。</span></span><br><span class="line"><span class="comment">//pair是一个标准库类型，定义在头文件utility中</span></span><br><span class="line"><span class="comment">//可以看作是有两个成员变量first和second的结构体</span></span><br><span class="line"><span class="comment">//并且重载了&lt;运算符</span></span><br><span class="line"><span class="comment">//当我们创建一个pair时必须提供两个类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="comment">//make_pair(v1, v2)函数返回由v1和v2初始化的pair</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="string">&quot;mike&quot;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">//如果插入的key之前已经存在了，则不会插入新的value替代原本的value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问映射</span></span><br><span class="line"><span class="comment">//直接使用[]进行访问</span></span><br><span class="line">m[<span class="string">&quot;mike&quot;</span>]; <span class="comment">//1</span></span><br><span class="line"><span class="comment">//如果m[&quot;x&quot;],x没有做过映射的话系统会自动生成一个x的映射，其对应的value为默认值。例如int的话为0。</span></span><br><span class="line"><span class="comment">//可以对映射赋予新的value</span></span><br><span class="line">m[<span class="string">&quot;x&quot;</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//有些时候我们并不希望系统为我们自动生成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断映射是否存在</span></span><br><span class="line">count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历映射</span></span><br><span class="line"><span class="comment">//使用迭代器进行访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">    it-&gt;first;</span><br><span class="line">    *it.second;</span><br><span class="line"><span class="comment">//这两种方式是一样的</span></span><br><span class="line"><span class="comment">//map是按照关键字从小到大遍历的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维map</span></span><br><span class="line"><span class="comment">//map不仅有map套map还有map套set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map套set</span></span><br><span class="line"><span class="comment">//记录全校学生的姓名但，难免会有重复的名字，我们可以对每个班级创建一个set，每个班级创建一个set，这样就能分辨不同班级的同名同学了</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &gt; s;</span><br><span class="line"><span class="comment">//此时我们就可以进行插入删除和查询操作了</span></span><br><span class="line"><span class="comment">//s[2]表示2班对应的姓名集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map套map</span></span><br><span class="line"><span class="comment">//此时无法解决同班同名的情况</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line"><span class="comment">//用第二维的int记录一个名字有多少个同学</span></span><br></pre></td></tr></table></figure>
<h3 id="栈和递归"><a href="#栈和递归" class="headerlink" title="栈和递归"></a>栈和递归</h3><p>满足一定约束的线性数据结构。其约束是：只允许在栈的一段插入和删除数据，这一端被称为栈顶；相对的，我们把另一端称为栈底。<br>该过程类似与子弹匣，当我们往其压入子弹时我们称之为<strong>push</strong>；射击子弹的时候，我们称之为<strong>pop</strong>。<br><strong>性质：先进后出，后进先出</strong><br>为了方便我们常用一个top来指示栈顶的位置</p>
<p>通常我们会把数据结构封装起来：将栈写成一个class或者struct</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">if</span>(top &lt; <span class="number">10000</span>)</span><br><span class="line">            data[top] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;栈溢出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(top &gt;= <span class="number">0</span>)</span><br><span class="line">          top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">topval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> data[top];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>STL中也有定义完的stack。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="comment">//除了支持pop和push等基本操作，还支持top()来获取栈顶元素</span></span><br><span class="line"><span class="comment">//empty()判断栈是否为空，size()计算栈中元素的个数</span></span><br></pre></td></tr></table></figure>
<h2 id="递-归"><a href="#递-归" class="headerlink" title="递 归"></a>递 归</h2><p>递归设计经验</p>
<ul>
<li>找重复</li>
<li>找重复中的变量</li>
<li>找参数变化趋势：设计出口</li>
</ul>
<p>递归是栈结构</p>
<ul>
<li>斐波拉契数列：递归指数级复杂度</li>
<li>汉诺塔问题</li>
</ul>
<h2 id="二分查找的递归解法"><a href="#二分查找的递归解法" class="headerlink" title="二分查找的递归解法"></a>二分查找的递归解法</h2><h2 id="深度优先搜素"><a href="#深度优先搜素" class="headerlink" title="深度优先搜素"></a>深度优先搜素</h2><p>简称dfs，是一个经典的搜索算法。<br>我们要将dfs和递归联系起来<br>这里的搜索是一种穷举的方式，即把所有的可行方案都列举出来，不断去尝试直到找到正确的答案。<br>递归是一种编程语言的实现，而深度搜索是一种思想，深度搜索可以使用递归实现。</p>
<p>搜索过程对应着一棵树，我们将其称为搜索树。<br>返回上一步的过程称为回溯</p>
<h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><h2 id="计蒜客刷题"><a href="#计蒜客刷题" class="headerlink" title="计蒜客刷题"></a>计蒜客刷题</h2><ul>
<li><p>倍数<br>注意int的取值范围</p>
</li>
<li><p>找质数<br>筛法求素数<br>cin和cout效率不如scanf和printf</p>
</li>
<li><p>阶梯三角形<br>这种代码填空题要先弄明白每个变量的含义，不能先入为主</p>
</li>
</ul>
<h1 id="集训"><a href="#集训" class="headerlink" title="集训"></a>集训</h1><h2 id="历年真题"><a href="#历年真题" class="headerlink" title="历年真题"></a>历年真题</h2><h3 id="2019B组省赛"><a href="#2019B组省赛" class="headerlink" title="2019B组省赛"></a>2019B组省赛</h3><h4 id="组队"><a href="#组队" class="headerlink" title="组队"></a>组队</h4><ul>
<li>程序解决<br>因为是五个人组队故可以使用5层for循环解决，中间判断5人不能为同一人。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="I后缀表达式"><a href="#I后缀表达式" class="headerlink" title="I后缀表达式"></a>I后缀表达式</h4><p>本题与后缀表达式相关知识关系buda<br><strong>解题思路</strong>：经过归纳总结对题中出现的几种情况进行分别讨论</p>
<h1 id="语言基础篇"><a href="#语言基础篇" class="headerlink" title="语言基础篇"></a>语言基础篇</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p><strong>函数模板的格式</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 形参名, <span class="keyword">class</span> 形参名, ......&gt;</span> 返回值类型 函数名(参数列表)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><p><em>算法！</em></p>
<h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><p><strong>二叉树的递归定义</strong>：二叉树要么为空，要么由 root 、left subtree 、right subtree 组成，而左右子树分别又是一棵二叉树，计算机中树一般倒置。</p>
<p><strong>树</strong>：；树和二叉树类似，区别在于每个结点不一定只有两棵子树。</p>
<h3 id="二叉树编号"><a href="#二叉树编号" class="headerlink" title="二叉树编号"></a>二叉树编号</h3><ul>
<li>对于每一个结点k，其左子节点和右子节点的编号分别为是2k和2k+1。</li>
<li>给定一棵包含$2^d$个节点(d为树的高度)的完全二叉树，从1开始编号，d层的首个节点为$2^{d-1}$，末尾节点为$2^{d}-1$</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="二叉树宽度优先遍历-bfs"><a href="#二叉树宽度优先遍历-bfs" class="headerlink" title="二叉树宽度优先遍历 bfs"></a>二叉树宽度优先遍历 bfs</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> have_value;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    Node():have_value(<span class="literal">false</span>), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照层次顺序遍历这棵树。此处使用队列，初始时只用一个根节点，然后每次取出一个父节点，就把他的左右子节点放入队列中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">ans.clear();</span><br><span class="line">q.push(root); <span class="comment">//初始时只有一个根结点</span></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">Node* u = q.front(); q.pop();</span><br><span class="line"><span class="keyword">if</span>(!u-&gt;have_value) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//有结点没有被赋值过，表明输入有误</span></span><br><span class="line">ans.push_back(u-&gt;v); <span class="comment">//增加到输出序列尾部</span></span><br><span class="line"><span class="keyword">if</span>(u-&gt;left != <span class="literal">NULL</span>) q.push(u-&gt;left); <span class="comment">//把左子结点（如果有）放进队列</span></span><br><span class="line"><span class="keyword">if</span>(u-&gt;right != <span class="literal">NULL</span>) q.push(u-&gt;right); <span class="comment">//把右子结点（如果有）放进队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//输入正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的深度优先遍历-dfs"><a href="#二叉树的深度优先遍历-dfs" class="headerlink" title="二叉树的深度优先遍历 dfs"></a>二叉树的深度优先遍历 dfs</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>Graph 描述的是一些个体之间的关系。与线性表和二叉树不同的是：这些个体之间既不是前驱后继的顺序关系，也不是祖先后代的层次关系，而是错综复杂的网状关系。</p>
<h3 id="用-bfs-求最短路径"><a href="#用-bfs-求最短路径" class="headerlink" title="用 bfs 求最短路径"></a>用 bfs 求最短路径</h3><p>按层遍历，每增加一层意味着增加一步，故第一次遍历到目的节点的层数为代表的步数为最短路径。</p>
<ul>
<li>迷宫问题</li>
</ul>
<p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210319105542812.png" alt="image-20210319105542812"></p>
<p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210319111251977.png" alt="image-20210319111251977"><br>使用bfs求出图的最短路之后，可以用递归方式打印最短的具体路径。如果路径非常长，递归可能会引起栈溢出，此时可以改用循环，用vector保存路径。</p>
<h2 id="波兰表达式"><a href="#波兰表达式" class="headerlink" title="波兰表达式"></a>波兰表达式</h2><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><ul>
<li>逆波兰表达式的计算</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算逆波兰表达式的值即后缀表达式的值可以使用栈进行计算</span></span><br><span class="line"><span class="comment">//原理:向栈中push数字当遇到计算符号时pop最上层两个数字进行计算后push</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;123+-&quot;</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ss；</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(s[i] &gt;= <span class="string">&#x27;0&#x27;</span>  &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        y = ss.top();  <span class="comment">//注意：先弹出的为后操作数</span></span><br><span class="line">        ss.pop();</span><br><span class="line">        x = ss.top();</span><br><span class="line">        ss.pop();     <span class="comment">//注意：两个操作数都要pop</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            ss.push(x + y);</span><br><span class="line">        <span class="keyword">if</span>*(s[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            ss.push(x - y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ss.push(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ss.yop() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="调度场算法"><a href="#调度场算法" class="headerlink" title="调度场算法"></a>调度场算法</h3><p>为了把较难处理的中缀表达式转化为容易处理的后缀表达式，引入调度场算法。<br>中缀表达式之所以难处理本质上因为优先级。如果我们把所有表达式全部按优先级加上括号，就很容易按照递归进行计算，但是这并不好实现。<br>因此我们换一种思路用栈来解决问题。</p>
<p><strong>使用栈的原因</strong>：当我们读到<code>a + b</code>的时候并不知道后面是什么，我们需要暂缓一步，等有了足够的信息再将其放出来。<br>足够的信息：假设<strong>乘方</strong>是优先级最高的运算，当我们读到<code>a ^ b</code>时无论后面是什么操作都可以立刻将其变为<code>a b ^</code>，但是当我们遇到其他计算就要考虑后面的计算符号，若是低于他的则可放心进行计算。</p>
<p><strong>归纳</strong>：栈顶的运算符被弹出的条件是<strong>优先级不低于新读入的运算符</strong>。当表达式结束时，也要把栈里剩余的运算符依次弹出。</p>
<p><strong>算法</strong>：</p>
<ol>
<li>读到数字：直接输出</li>
<li>读到运算符：如果栈顶的运算符优先级不低于(大于等于)该运算符，则输出栈顶的运算符并使之出栈，直到栈空或不满足上述条件为止；然后入栈。</li>
<li>当读入完毕时，依次输出并弹出栈顶运算符，直到栈被清空。</li>
</ol>
<p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/v2-5d60fe34ae244a296cd3562617facea7_r.png" alt="v2-5d60fe34ae244a296cd3562617facea7_r"></p>
<p><strong>处理括号</strong>：</p>
<ol>
<li>读到数字：直接输出</li>
<li>读到一般运算符：果栈顶的运算符优先级不低于(大于等于)该运算符，则输出栈顶的运算符并使之出栈，直到栈空或不满足上述条件为止；然后入栈。</li>
<li>读到左括号：直接入栈</li>
<li>读到右括号：输出栈顶运算符并使之出栈知道栈顶为左括号为止，令左括号出栈。实质：一个括号实际上就是重新建一个栈进行括号内的调度场算法</li>
<li>当读入完毕时，依次输出并弹出栈顶运算符直到栈被清空<br>奇巧淫技：可以在表达式的最末尾加上一个<code>#</code>将其优先级定义为最低，遇到此运算符时即为表达式的结尾</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">    &#125;data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;pri;</span><br><span class="line">pri[<span class="string">&#x27;+&#x27;</span>] = pri[<span class="string">&#x27;-&#x27;</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> <span class="built_in">exp</span>, node postP[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0.</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exp</span> += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">    <span class="keyword">while</span>(q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(str[i]))&#123;</span><br><span class="line">            t = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>[++i])&#123;</span><br><span class="line">                t = t*<span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            postP[cnt].data.num = t;</span><br><span class="line">            postP[cnt++].tag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk,empty() &amp;&amp; pri[str[i]] &gt; pri[stk.top()]) &#123;</span><br><span class="line">                postP[cnt]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="fropen"><a href="#fropen" class="headerlink" title="fropen"></a>fropen</h3><p>头文件 <stdio.h></stdio.h></p>
<p>fropen(path, mode, stream)</p>
<p>path:路径<br>mode:文件打开方式”r”-只读， “w”-写<br>stream:stdin-标准输入流,stdout-标准输出流</p>
<h2 id="动态规划初步"><a href="#动态规划初步" class="headerlink" title="动态规划初步"></a>动态规划初步</h2><ul>
<li>状态及状态转移方程</li>
<li>最优子结构和重叠子问题</li>
<li>递推法和记忆化搜素求解数字三角形问题</li>
<li>DAG上动态规划的常见思路、两种状态定义的方法和刷表法</li>
<li>记忆化搜索再实现方面的注意事项</li>
<li>记忆化搜索和递推中输出方案的方法</li>
<li>递推中滚动数组的应用</li>
</ul>
<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210319175422751.png" alt="image-20210319175422751"></p>
<p><strong>分析</strong>：<br>回溯法可以用来解决此问题，但是当n特别大时其速度让人难以忍受。<br><strong>抽象</strong>：把当前位置(i, j) 看作一种状态，然后定义状态的指标函数<code>d(i, j)</code>为从格子(i, j) 出发，能得到的最大和。在这个状态的定义下，答案为<code>d(1, 1)</code>。<br><strong>状态转移方程</strong>：从格子<code>(i, j)</code>出发有两种方案：往左走或者往右走。由于可以没有限制的在两个决策中做决定，所以应选择指标函数较大的那个。</p>
<script type="math/tex; mode=display">d(i, j) = a(i, j) + max{d(i+1, j), d(i+1, j+1)}</script><p><strong>最优子结构</strong>：全局最优解包含局部最优解。</p>
<p><strong>记忆化搜索与递推</strong>：<br>计算方法1：使用递归(需要注意边界处理)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i][j] + (i == n ? max(solve(i+<span class="number">1</span>, j), solve(i+<span class="number">1</span>, j+<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的方法是正确的但是时间效率太低，其原因在于重复计算。</p>
<p>计算方法2：递推计算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    dp[n][j] = a[n][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        d[i][j] = a[i][j] + max(d[i+<span class="number">1</span>][j], d[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算方法3：记忆化搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[i][j] ＞= <span class="number">0</span>) <span class="keyword">return</span> d[i][j];</span><br><span class="line">    <span class="keyword">return</span> d[i][j] = a[i][j] ＋ (i == n ? <span class="number">0</span> : max(solve(i＋<span class="number">1</span>,j),solve(i＋<span class="number">1</span>,j＋<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>千万不要忘记在计算之后把它保存在d[i][j]中。根据C语言“赋值语句本身有返回值”的规定，可以把保存d[i][j]的工作合并到函数的返回语句中。<br>上述程序的方法称为记忆化（memoization），它虽然不像递推法那样显式地指明了计算顺序，但仍然可以保证每个结点只访问一次可以用记忆化搜索的方法计算状态转移方程。当采用记忆化搜索时，不必事先确定各状态的计算顺序，但需要记录每个状态是否已经计算过。</p>
<h3 id="多阶段决策问题"><a href="#多阶段决策问题" class="headerlink" title="多阶段决策问题"></a>多阶段决策问题</h3><h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210320113319787.png" alt="image-20210320113319787"></p>
<p><strong>分析</strong>：只凭“剩余体积”这个状态已经无法得知每个物品是否已经用过。<br>使用$d(i, j)$表示当前在第i层，背包容量为j的最优决策即最大重量和，状态转移方程为：</p>
<script type="math/tex; mode=display">d(i, j) =</script><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="MC生存买东西"><a href="#MC生存买东西" class="headerlink" title="MC生存买东西"></a>MC生存买东西</h4><p><strong>题目描述</strong>：<br>一个人的背包有21格。<br>一开始他的背包里有m件不同的物品（不能卖）。<br>他要卖n种物品，每种物品有ai件,价值bi,一格可以放ci个，<br>名字sti（0&lt;sti的长度&lt;100)<br>相同的物品可以放同一格(只要没放满）。<br>问他跑一次最多能卖多少钱。</p>
<p><strong>输入格式</strong>：<br>第一行：m,n;<br>下面n行：ai, bi, ci, sti.</p>
<p><strong>输出格式</strong>:<br>最多能买的钱</p>
<p><strong>问题分析</strong>：<br>简化为01背包问题，预期不同的时当取某一个物品时我们可以选择其个数，<br>i, j分别表示i个格子，z种商品<br>d(i, j) 表示这i个格子和前i种商品可以卖的最多钱数<br>d(i, j) = max(d(i , j-1), d(i - w, j))<br>当提供前z种商品时其当前最大价值不选取这种商品仍用前j-1种商品创造的最大价值与选用了这种商品选用w个格子占用的最大价值，其中w需要进行遍历</p>
<p><strong>code</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001    <span class="comment">//N </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXV 101     <span class="comment">//V </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> capacity 21  <span class="comment">//背包容量 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, V, cnt;</span><br><span class="line"><span class="keyword">int</span> s[MAXN], c[MAXN], v[MAXN];   <span class="comment">//s为数量，c为价值，v为多少个为一格 </span></span><br><span class="line"><span class="keyword">int</span> f[MAXV];                     <span class="comment">//占i格的最大价值f[i] </span></span><br><span class="line"><span class="built_in">string</span> name[MAXN];               <span class="comment">//物品的名称 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">upv</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span> </span>&#123;   <span class="comment">//空间向上取整：有a个，一格最多放x个，返回占多少格 </span></span><br><span class="line">    <span class="keyword">int</span> r = x; </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= a) <span class="keyword">return</span> r/x;</span><br><span class="line">        r += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    V = capacity - m;  <span class="comment">//还剩几格 </span></span><br><span class="line">    cnt = <span class="number">1</span>;           <span class="comment">//记录合并后的物品总数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[cnt] &gt;&gt; c[cnt] &gt;&gt; v[cnt] &gt;&gt; name[cnt];</span><br><span class="line">        <span class="comment">/*以下是合并同种物品 */</span> </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i<span class="number">-1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(name[j] == name[i]) &#123;</span><br><span class="line">                s[j] += s[i];</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt --;    </span><br><span class="line">    <span class="comment">/*多重背包模版*/</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=s[i]; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = upv(k, v[i]); <span class="comment">//单独处理占的格子 </span></span><br><span class="line">                <span class="keyword">if</span>(j - w &lt; <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">//格子不够 </span></span><br><span class="line">                f[j] = max(f[j], f[j-w] + c[i] * k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int k  = l + rand() % (r-l+1);</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= r; i+= <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    srand(a[k], a[l]);</span><br><span class="line">    <span class="keyword">while</span>(a[i] &lt;= a[<span class="number">1</span>]) i++;</span><br><span class="line">    <span class="keyword">while</span>(a[j] &gt;= a[i]) j--;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; j )</span><br><span class="line">        swap(a[l], a[i]);</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> == k)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> &lt; k)</span><br><span class="line">        select(a, l, i<span class="number">-1</span>, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        select(a, i+<span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性选择时间选择</span></span><br><span class="line"><span class="comment">/*****</span></span><br><span class="line"><span class="comment">每次划分保证每次选择两区间的长度都大于某个常数</span></span><br><span class="line"><span class="comment">对于一个很大的数组如何选择k和a[0]进行交换保证长度大于某个常数</span></span><br><span class="line"><span class="comment">比方说：2 3 5 8 6 2 3 10 7 9 8 4 12</span></span><br><span class="line"><span class="comment">将其分为三组分别取中位数 5 7 8</span></span><br><span class="line"><span class="comment">将n个元素分组每组分为5个元素，将每组进行排序，求出其中的中位数，再将这n/5个中位数进行排序求出其中位数，如果为偶数个则选取较大的，以这个数为基准</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>
<h2 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h2><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>我们接触过很多排序算法，但大部分都不怎么用得上（尤其是那些$O(n^{2})$的算法，<strong>快速排序</strong>和<strong>归并排序</strong>基本上已经够用了，他们的平均时间复杂度都是$O(nlogn)$。实际上，学术上已经证明了，任何<strong>基于比较的排序算法</strong>的时间复杂度都不能比这更优了。即只任意给出偏序关系，那不可能存在小于$O(n log n)$的排序算法。</p>
<h3 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h3><p>定义：给定线性序集中n个元素和一个整数k，找出这n个元素中第k小的元素。</p>
<ol>
<li><p>在某些特殊情况下，很容易设计出解选择问题的线性时间算法。如：当要选择最大元素或最小元素时，显然可以在O(n)时间完成。（一趟比较即可）</p>
</li>
<li><p>一般的选择问题，特别是中位数的选择问题似乎比最小（大）元素要难。但实际上，从渐近阶的意义上，它们是一样的。也可以在O(n)时间完成。</p>
</li>
</ol>
<p><strong>算法</strong>：</p>
<ol>
<li><p>将n个输入元素划分成n/5（向上取整）个组，每组5个元素，最多只可能有一个组不是5个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共n/5（向上取整）个。</p>
</li>
<li><p>递归调用select来找出这n/5（向上取整）个元素的中位数。如果n/5（向上取整）是偶数，就找它的2个中位数中较大的一个。以这个元素作为划分基准。</p>
</li>
</ol>
<p><strong>注意</strong>：</p>
<ol>
<li><p>设中位数的中位数为x，则比x小和比x大的至少有3*(n-5)/10个：3表示中位数比x小的每一组中有3个元素比x小， n/5-1表示有5个数的数组， 1/2表示大概有1/2的数组的中位数比x小</p>
</li>
<li><p>当$n&gt;=75$时。$3*(n-5)/10 &gt;= n/4$，所以按此基准划分所得的2个子数组的长度都至少缩短$1/4$，也就为原长的$3/4$</p>
</li>
</ol>
<p><strong>code</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> i1, j, l1, j1, m = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int k  = l + rand() % (r-l+1);</span></span><br><span class="line">    <span class="comment">//分组冒泡排序并找到中位数将其置于数组之首</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;=r; i+=<span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i1 = i; i1 &lt; i+<span class="number">5</span>; i1++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j1 = i+<span class="number">1</span>; j1&lt;i+<span class="number">5</span>; j1++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i1] &gt; a[j1]) &#123;</span><br><span class="line">                    swap(a[i1], a[j1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将各分小组的中位数置于队首</span></span><br><span class="line">        swap(a[m++], a[j1]);</span><br><span class="line">    &#125;</span><br><span class="line">    k = select(a, <span class="number">1</span>, m<span class="number">-1</span>, (m<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(a[i] &lt;= a[<span class="number">1</span>]) i++;</span><br><span class="line">    <span class="keyword">while</span>(a[j] &gt;= a[i]) j--;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; j )</span><br><span class="line">        swap(a[l], a[i]);</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> == k)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> &lt; k)</span><br><span class="line">        select(a, l, i<span class="number">-1</span>, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        select(a, i+<span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>求解一个复杂问题，可以将其分解成若干个子问题，子问题可以进一步分解为更小的问题，直到所得的小问题可以分解为基本问题，并且其求解方法是已知的，可以直接求解为止。<br>分治法是一种设计算法策略，要求分解所得的子问题是同类问题，并且原问题的解可以通过组合子问题的解来获取。</p>
<h3 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h3><p>分治法的思想就是：分而治之。一个问题能够用分解法的要素为：</p>
<ul>
<li>问题能够分解为相对规模较小、相互独立且与原问题类型相同的子问题</li>
<li>子问题足够小时可以直接求解</li>
<li>能够将子问题的解组合为原问题的解</li>
<li>由于分治法要求分解同类子问题，并允许不断分解，使问题规模逐渐减小，最终可以用已知的方法求解足够小的子问题故其很自然的就要使用<strong>递归算法</strong>。</li>
</ul>
<p><strong>分治策略的控制抽象</strong>；</p>
<ul>
<li>分治法：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SolutionType <span class="title">DandC</span><span class="params">(ProblemType P)</span> </span>&#123;</span><br><span class="line">    ProblemType P1, P2, P3, Pk;</span><br><span class="line">    <span class="keyword">if</span>(Small(P)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> S(P);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Divide(P, P1, P2, P3, Pk);</span><br><span class="line">        <span class="keyword">return</span> Combine(DandC(P1), DandC(P2), DandC(Pk));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Small()为一个布尔类型的函数判断P是否足够小</span></span><br><span class="line"><span class="comment">//Combine()函数将各子问题的解组合成原始问题的解</span></span><br><span class="line"><span class="comment">//Divide()函数以某种形式将问题P分解’</span></span><br><span class="line"><span class="comment">//S()函数针对足够小的问题进行求解</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一分为二的分治法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SolutionType <span class="title">DandC</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Small(left, right))</span><br><span class="line">        <span class="keyword">return</span> S(left, right);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> m = Divide(left, right);</span><br><span class="line">        <span class="keyword">return</span> Combine(DandC(left, m), DandC(m + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求最大最小元"><a href="#求最大最小元" class="headerlink" title="求最大最小元"></a>求最大最小元</h3><p><em>运用分治法在一个元素集合中寻找最大元和最小元问题。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::MaxMin(<span class="keyword">int</span> i, <span class="keyword">int</span> j, T&amp; max, T&amp; min) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前置条件：i和j,0 &lt;= i &lt;= j &lt; 表长，是表的下界范围</span></span><br><span class="line">    T min1, max1;</span><br><span class="line">    <span class="keyword">if</span>(i == j) max = min = l[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == j - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i] &lt; l[j]) &#123;</span><br><span class="line">            max = l[j];</span><br><span class="line">            min = l[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            max = l[i];</span><br><span class="line">            min = l[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span>  m = (i+j) / <span class="number">2</span>;</span><br><span class="line">        MaxMin(i, m, max, min);</span><br><span class="line">        MaxMin(m+<span class="number">1</span>, j, max1, min1);</span><br><span class="line">        <span class="keyword">if</span>(max &lt; max1) max = max1;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; min1) min = min1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">子问题：各个分组求最大最小</span></span><br><span class="line"><span class="comment">Combine：将各个分组的的最大最小进行比较</span></span><br><span class="line"><span class="comment">足够小：i == j 或着 i = j - 1</span></span><br><span class="line"><span class="comment">*****/</span></span><br></pre></td></tr></table></figure>
<h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p><em>在表中搜索确定一个关键字值为给定的元素是一种是一种常见的运算。</em></p>
<h4 id="用分治法求解"><a href="#用分治法求解" class="headerlink" title="用分治法求解"></a>用分治法求解</h4><p>有一个长度为n的有序表，要求在表中搜索与给定元素x有相同关键字值的元素。若n=0，搜索失败；若n&gt;0，则可将有序表分解成若干个子表。最简单的做法是分解成两个子表。假定以元素$a_{m}$为划分点。则将其与给定元素x进行比较。比较结果有三种情况：</p>
<ul>
<li>x &lt; $a_{m}$，在前半部分子表中寻找</li>
<li>x = $a_{m}$，搜索成功</li>
<li>x &gt; $a_{m}$，在后半部分子表中搜索</li>
</ul>
<p>二分搜索框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SortableList&lt;T&gt;::BSearch(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> left, <span class="keyword">int</span> right) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = Divide(left, right);</span><br><span class="line">        <span class="keyword">if</span>(x &lt; l[m) <span class="keyword">return</span> BSearch(x, left, m<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; l[m]) <span class="keyword">return</span> BSearch(x, m+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对半搜索"><a href="#对半搜索" class="headerlink" title="对半搜索"></a>对半搜索</h4><p>对半搜索是一种二分搜索。<br>设当前搜索子表为：$a_{left},……,a_{right}$，令</p>
<script type="math/tex; mode=display">m = (left + right) / 2</script><p>这种二分搜索被称为对半搜索，将表划分成几乎等大小的两个子表</p>
<p><strong>对半搜索递归算法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SortableList&lt;T&gt;::BSearch(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> left, <span class="keyword">int</span> right) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; l[m])</span><br><span class="line">            <span class="keyword">return</span> BSearch(x, left, m<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; l[m])</span><br><span class="line">            <span class="keyword">return</span> BSearch(x, m+<span class="number">1</span>, right)；</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定理</strong>：对于$n \geq 0$，对半搜索递归函数是正确的。</p>
<p><strong>对半搜索的迭代算法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SortacleList&lt;T&gt;::BSearch(<span class="keyword">const</span> T&amp; x)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> m, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        m = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; l[m])</span><br><span class="line">            right = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; l[m])</span><br><span class="line">            left = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉判定树"><a href="#二叉判定树" class="headerlink" title="二叉判定树"></a>二叉判定树</h4><p><em>二分搜索时的算法行为可以用一棵二叉树来描述。</em><br>我们称这棵描述搜索算法执行过程的二叉树为<strong>二叉判定树</strong>。<br><em>略</em></p>
<h3 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h3><p><strong>排序</strong>又称为分类。<br>分治法求解排序问题的思想很简单：按某种方式将序列分成两个或多个子序列，再将已排序的子序列合并成一个有序序列即可。<br><strong>合并排序</strong>和<strong>快速排序</strong>是两种典型的符合分治策略的排序算法。</p>
<h4 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h4><p><em>merge sort 的基本运算就是把两个或者多个有序序列合并成一个有序序列，下面介绍最基本的合并算法；两路合并运算：</em></p>
<ul>
<li>合并两个有序序列<br>实现这种合并的方法十分简单：比较两个有序序列的最小值，输出其中较小者，然后重复此过程，直到其中一个序列为空，如果另一个还有元素未输出则将剩余依次输出即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::Merge(<span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    T* temp = <span class="keyword">new</span> T[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((i &lt;= mid) &amp;&amp; (j &lt;= right))&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i] &lt;= l[j])</span><br><span class="line">            temp[k++] = l[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++] = l[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        temp[k++] = l[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right)</span><br><span class="line">        temp[k++] = l[j++];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, k = left;l&lt;= right;)</span><br><span class="line">        l[k++] = temo[i++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>分治法求解<br>算法描述：将待排序的元素序列一分为二，得到两个长度基本相等的子序列，类似对半搜索的做法：然后最两个子序列分别排序，如果子序列较长，还可以继续细分，直到子序列的长度不超过1为止；当分解所得的子序列已排列有序时，可以采用上面的方法进行合并，实现将子问题的解组成成原问题的解。<br>分治法审视问题的视角：元素一分为二，分别进行排序，当序列为空或只有一个元素时别人为子问题足够小以至于可以直接解决。</p>
</li>
<li><p>合并排序算法</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::MerageSort()</span><br><span class="line">&#123;</span><br><span class="line">    MergeSort(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::MerageSort(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        MerageSort(left, mid);</span><br><span class="line">        MerageSort(mid+<span class="number">1</span>, right);</span><br><span class="line">        Merge(left, mid, left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><em>quick sort 又被称为 分划交换排序。</em><br>采用一种特殊的分划操作对排序问题进行求解，其分解方法为：</p>
<ol>
<li>在待排序的序列中($K_0, K_1,…K_{n-1}$)中选择一个元素作为<strong>分划元素</strong>，即<strong>主元</strong>。</li>
<li>不妨假定$K_a$为主元，经过一趟特殊的分划处理将原序列中的元素重新排列，值得以主元为轴心，将序列分为左右两个子序列。</li>
<li>使得主元左侧子序列中所有的元素都不大于主元，右侧都不小于。</li>
<li>在新的序列中$K_a$处于位置$j$处，则新序列应满足上述条件。这样新序列就被分为了三部分：主元和左右两个子序列。&lt;/br&gt;$(K_0,…K_{j-1})K_j(K_{j+1},…,K_{n-1})$</li>
</ol>
<p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/QuickSort2.png" alt="QuickSort2"><br><strong>分划</strong>：以主元为轴心，对一个序列按上述要求重新排列，并分解为两个子序列的国车过。<br><strong>实质</strong>：分划就是对原序列排序问题分解成两个待解决的、性质相同的子问题。</p>
<p>快速排序中，使用分划操作将一个问题分解成两个相互独立的子问题。当子序列为一个元素或为空序列时我们认为其足够小。无需进行任何处理。<br>分治法要求分别求解子问题后，设法将子问题的解组合成原问题的解，这一点在快速排序下变得非常简单：由于划分操作，左边序列均不大于主元，右边序列均不小于主元。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">合并排序</th>
<th style="text-align:center">快速排序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">分治策略</td>
<td style="text-align:center">分治策略}</td>
</tr>
<tr>
<td style="text-align:center">问题分解简单：一分为二</td>
<td style="text-align:center">问题分解困难：分化操作</td>
</tr>
<tr>
<td style="text-align:center">子问题解合并原问题解较难</td>
<td style="text-align:center">子问题解合并原问题相对简单</td>
</tr>
</tbody>
</table>
</div>
<p><strong>分划操作</strong>：<br><em>快速排序的核心。</em><br>每趟划分选择序列中哪个元素是需要考虑的，最简单的做法就是选择序列中的第一个元素。<br><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/quick_sort_partition_animation.gif" alt="quick_sort_partition_animation"><br><em>注:此图为以末尾元素为主元</em><br>算法要求在待排序序列尾部设置一个大值$\infty$作为哨兵防止指针右移过程中移出序列之外，不能终止。这种情况当初始序列以递减次序列排序时就会发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SortableList&lt;T&gt;::Partition(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;<span class="comment">//前置条件：left &lt;= right</span></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(l[i] &lt; l[left])；</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">while</span>(l[j] &gt; l[left]);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            Swap(i,j); <span class="comment">//交换两个元素l[i] 和 l[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i &lt; j);</span><br><span class="line">    Swap(left, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>快速排序算法<br>调用分划函数，以主元为轴心分成两个子序列。然后分别用递归调用自身对这两个子序列实施快速排序，将他们排成有序序列。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::QuickSort()&#123;</span><br><span class="line">    QuickSort(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::QuickSort(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = Partition(left, right);</span><br><span class="line">        QuickSort(left, j<span class="number">-1</span>);</span><br><span class="line">        QuickSort(j+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>改善快速排序算法</li>
</ul>
<ol>
<li>改进主元选取方法：一是选取$K_{(left+right)/2}$、二是选取$left ~ right$间的随机整数、三是选取$K_{left}$、$K_{(left+right)/2}$和$K_{right}$中的一个。</li>
<li>快速排序中子序列会变得越来越小，当子序列的长度小到一定程度时，快速排序的速度反而不如一些简单的排序，如直接插入法。</li>
<li>递归算法的效率往往不如非递归算法，可以设计非递归的排序算法：使用一个堆栈，在一次分划操作后，将其中一个子序列范围的上下界进栈保存，而对另一个序列继续进行分划排序。当对此子序列排序时，仍将分划的到的一个子序列的上下界进栈保存，对另一个子序列继续进行排序。直到足够小为止，再从栈中取出保存的某个尚未排序的子序列上下界，对该子序列进行快速排序。</li>
</ol>
<h3 id="选择问题"><a href="#选择问题" class="headerlink" title="选择问题"></a>选择问题</h3><h3 id="斯特拉森矩阵乘法"><a href="#斯特拉森矩阵乘法" class="headerlink" title="斯特拉森矩阵乘法"></a>斯特拉森矩阵乘法</h3>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/03/Java%E4%B8%8EAndroid%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/" rel="prev" title="Java与Android移动应用开发">
                  <i class="fa fa-chevron-left"></i> Java与Android移动应用开发
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/05/vscode%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" rel="next" title="vscode使用指南">
                  vscode使用指南 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiahui Wang</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>-->

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
