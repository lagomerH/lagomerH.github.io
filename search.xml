<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>神经网络与深度学习-note</title>
    <url>/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/</url>
    <content><![CDATA[<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120081213727.png" alt="image-20210120081213727"></p>
<p><em>记录Michael Nielsen 的《神经网络与深度学习》学习过程。</em></p>
<a id="more"></a>
<h1 id="使用神经网络识别手写数字"><a href="#使用神经网络识别手写数字" class="headerlink" title="使用神经网络识别手写数字"></a>使用神经网络识别手写数字</h1><p>识别数字主要思想：获取大量的手写数字，常称作训练样本，然后开发出一个可以从这些训练样本中进行学习的系统。即神经网络使用样本来自动推断出识别手写数字的规则。</p>
<p>提高准确性：通过增加训练样本的数量，神经网络可以学到更多关于手写数字的知识。</p>
<h2 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h2><h3 id="感知器的定义"><a href="#感知器的定义" class="headerlink" title="感知器的定义"></a>感知器的定义</h3><ul>
<li>依据权重来做出决定的设备。</li>
<li>接收几个二进制输入，产生一个二进制输出</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120074657848.png" alt="image-20210120074657848"></p>
<ul>
<li><p>引入<strong>权重</strong>规则，用其表示相应输入对于输出的重要性。</p>
</li>
<li><p><strong>阈(yu)值</strong>是一个实数，一个神经元的参数。神经元的输出(0 or 1)由分配权重后的总和与阈值的大小关系决定。</p>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120075501785.png" alt></p>
</li>
</ul>
<h3 id="简化感知器的数学描述"><a href="#简化感知器的数学描述" class="headerlink" title="简化感知器的数学描述"></a>简化感知器的数学描述</h3><ul>
<li><p>第一个变动是用w和x对应权重和输入的向量的点乘。</p>
</li>
<li><p>第二个变动用感知器的偏置b=-threshold代替。</p>
</li>
<li><p><strong>偏置</strong>：一种标识让感知器输出1(激活感知器)有多容易的估算。偏置非常大时输出1是很容易的，偏置非常小时输出1则很困难。</p>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120092559889.png" alt></p>
</li>
</ul>
<h3 id="感知器网络"><a href="#感知器网络" class="headerlink" title="感知器网络"></a>感知器网络</h3><ul>
<li><p>第一层感知器——通过权衡输入依据做出三个简单决定。</p>
</li>
<li><p>第二层感知器——权衡第一层的决策结果并作出决定。以这种方式，二层感知器可以比一层感知器做出更复杂和抽象的决策。</p>
</li>
<li><strong>一个感知器只有一个输出</strong>，下图箭头仅仅便于说明一个一个感知器的输出被用于多个感知器。</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120093803752.png" alt="image-20210120093803752" style="zoom: 67%;"></p>
<h3 id="感知器计算基本逻辑的功能"><a href="#感知器计算基本逻辑的功能" class="headerlink" title="感知器计算基本逻辑的功能"></a>感知器计算基本逻辑的功能</h3><ul>
<li><p>运算基础，例如“<strong>与</strong>”，“<strong>或</strong>”和“<strong>与非</strong></p>
</li>
<li><p>与非门感知器：输入00产生1，输入11产生0</p>
</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120103347029.png" alt="image-20210120103347029"></p>
<ul>
<li>与非门是通用运算，以此为基础我们可以用感知器网络来计算任何逻辑功能</li>
<li>构建一个电路将两个二进制数相加</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120115000598.png" alt="image-20210120115000598" style="zoom:80%;"></p>
<ul>
<li>将与非门替换为感知器</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120115226182.png" alt="image-20210120115226182" style="zoom:67%;"></p>
<ul>
<li>最左边感知器的输出被两次作为底部感知器的输入。进而我们可以简单把两条线合并为到一个权重为-4的连接</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120115424951.png" alt="image-20210120115424951" style="zoom: 67%;"></p>
<ul>
<li><strong>输入层</strong>：将<code>x1</code> <code>x2</code>这样的感知器网路左边的浮动变量可以画一层额外的感知器来方便输入编码</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120115831884.png" alt="image-20210120115831884" style="zoom:67%;"></p>
<ul>
<li>输入感知器：可以完全不将其看作感知器，而是简单的定义为输出期望值的特殊单元。</li>
</ul>
<h2 id="S型神经元"><a href="#S型神经元" class="headerlink" title="S型神经元"></a>S型神经元</h2><h3 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h3><p>自动调节人工神经元的权重和偏置</p>
<ul>
<li>学习过程：如果对权重(or 偏置)的微小的改动能够仅仅引起输出的微小变化，那么我们可以利用这一事实来修改权重和偏置，让我们的网络表现得像我们想要的那样。假设网络误将一个”9“识别为”8“。我们能够计算出对权重和偏置的微小改动，使网络将其正确识别。我们重复这个工作，反复修改权重和偏置来产生更好的输出。</li>
<li>问题：网络中单个感知器的权重或偏置的微小改动有时候会引起那个感知器的输出完全翻转，如0变到1。这样的翻转可能接下来引起其余网路的行为以极其复杂的方式完全改变。虽然”9“可能别正确分类，网络在其他图像上的行为很可能以一些很难控制的方式被完全改变。这使得逐步修改权重和偏置来让网络接近期望行为变得困难。</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120173437965.png" alt="image-20210120173437965" style="zoom:80%;"></p>
<ul>
<li><p>解决方案：引入一种称为S型神经元的新的人工神经元来克服这个问题。S型神经元和感知器类似，但是被修改为权重和偏置的微小改动只引起输出的微小变化(这对于让神经元网络学习起来是很关键的)。</p>
</li>
<li><p><strong>S型神经元</strong>：有多个输入，这些输入可以取[0,1]中的任意值，而不仅仅是0和1。具有权重和偏置。但输出不是0或者1，而是<code>sigma(w·x+b)</code>,该函数为S型函数(逻辑函数)，定义为：</p>
</li>
</ul>
<p>  <img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120180707163.png" alt="image-20210120180707163"></p>
<p>  代入神经元参数为：</p>
<p>  <img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120180751519.png" alt="image-20210120180751519"></p>
<ul>
<li>S型神经元和感知器关系：当<code>z=w·x+b</code>取很大或者很小时其S型神经元的行为和感知器非常近似。只有<code>z</code>取中间值时与感知模型有较大的偏离。</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120181846815.png" alt="image-20210120181846815" style="zoom:67%;"></p>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120182011643.png" alt="image-20210120182011643" style="zoom:67%;"></p>
<ul>
<li>如果<code>sigma</code>函数是个阶跃函数，那么S型神经元将会成为一个感知器。之所以利用<code>sigma</code>函数是为了得到一个平滑的感知器。其<strong>平滑特性</strong>正是解决问题的关键因素，意味着权重和偏置的微小变化会从神经元产生一个微小的输出变化，利用微积分我们可以得到下式：</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120182810071.png" alt="image-20210120182810071" style="zoom:80%;"></p>
<ul>
<li><p>理解:<code>Δoutput</code>是一个反应Δwj和Δb的线性函数，使得选择权重和偏置的微小变化来达到输出的微小变化的运算变得容易。因此，当S型神经元有更多和感知器相同的本质的行为时，计算如何变化权重和偏置来使输出变化会更加容易。</p>
</li>
<li><p>为什么选用上面的<code>sigma</code>函数：对于<code>sigma</code>函数重要的是形状而不是精确形式，选用该函数的目的是简化数学计算，因为指数在求导时有些可爱的属性。</p>
</li>
<li>S型神经元输出的解释：并非只输出0 or 1，但我们可以设定一个约定来解决这个问题，例如约定任何至少为0.5的输出表示为“这是某个数字”</li>
</ul>
<h2 id="神经网络的架构"><a href="#神经网络的架构" class="headerlink" title="神经网络的架构"></a>神经网络的架构</h2><p>假设我们有这样的网络：</p>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120194421991.png" alt="image-20210120194421991" style="zoom:80%;"></p>
<ul>
<li><strong>输入层</strong>：网格中最左边的，其中的神经元为<strong>输入神经元</strong>。</li>
<li><strong>输出层</strong>：最右边的，有且只有一个<strong>输出神经元</strong>。</li>
<li><strong>隐藏层</strong>：中间包含既不输入也不输出的神经元的层。</li>
<li><strong>多层感知器</strong> or <strong>MLP</strong>：这种网络尽管是由S型神经元而不是感知器构成，但也称为多层感知器。</li>
</ul>
<p>设计输入输出层通常是比较直接的，隐藏层的设计则堪称一门艺术。特别是，通过一些简单的经验法则来总结隐藏层的设计流程是不可行的。相反，神经网络的研究人员已经为隐藏层开发了许多 设计最优法则。</p>
<ul>
<li><strong>前馈神经网络</strong>：以上一层的输出作为下一层的输入。这意味着网络中是没有回路 的——信息总是向前传播，从不反向反馈。</li>
<li>递归神经网络：反馈环路在其中是可行的，其设计思想是具有休眠前会在一段有限时间内保持激活状态的神经元。</li>
</ul>
<h2 id="一个简单的分类手写数字的网络"><a href="#一个简单的分类手写数字的网络" class="headerlink" title="一个简单的分类手写数字的网络"></a>一个简单的分类手写数字的网络</h2><p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120194325646.png" alt="image-20210120194325646" style="zoom:80%;"></p>
<ul>
<li>网络的输入层包含给输入像素的值进行编码的神经元 ，含有784=28*28个神经元。输入像素是灰度级的，值为1.0表示黑色，值为0.0表示白色，中间数值表示逐渐暗淡的灰色。</li>
<li>网络的隐藏层用n来表示神经元的数量。</li>
<li>网络的输出层包含10个神经元。如果第一个神经元激活，即其输出近似为1，那么表明 网络认为数字是一个0。更确切地说，我们把神经元的输出赋予编号0到9，并计算哪个神经元有最高的激活值。</li>
<li>思考：为什么使用10个输出神经元而不是4个。2^4=16&gt;10完全可以表示10个数字。</li>
<li></li>
</ul>
<h2 id="使用梯度下降算法进行学习"><a href="#使用梯度下降算法进行学习" class="headerlink" title="使用梯度下降算法进行学习"></a>使用梯度下降算法进行学习</h2><ul>
<li><p>训练数据集：用来学习的数据集。</p>
</li>
<li><p><strong>MNIST数据集</strong>：其中包含有数以万计的连带着正确分类器的手写数字的扫描图像。</p>
<p>我们将使用符号x来表示一个训练输入。为了方便，把每个训练输入x看作一个28*28=784维的向量。我们用y=y(x)表示对应的期望输出，这里的y是一个10维向量。例如有一个“6”的训练图像x，那么y(x) = (0,0,0,0,0,0,1,0,0,0)<sup>T</sup> 则是网络的期望输出。T是转置操作，把一个行向量转化成列向量。</p>
</li>
</ul>
<ul>
<li><strong>代价 函数</strong>：我们希望有一个算法，能够让我们找到权重和偏置，以至于网络的输出y(x) 能够拟合所有的训练输入x。为了量化我们如何实现这个目标，我们定义了代价函数：</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210121195359475.png" alt="image-20210121195359475" style="zoom:80%;"></p>
<ul>
<li><code>w</code>：所有的网络中权重的集合；<code>b</code>：所有的偏置；<code>n</code>：训练输入数据的个数；<code>a</code>：当输入为 x 时输出的向量；符号<code>||v||</code>指的是向量v的模。</li>
<li>我们把C称为<strong>二次代价函数</strong> or <strong>均方误差</strong> or <strong>MSE</strong>。</li>
<li><p>该函数是非负的，其值相当小，C(w,b) $\approx$ 0 。精确的说是在对于所有训练输入x，y(x)接近于输出a时。</p>
</li>
<li><p>我们需要使我们的学习算法找到合适的权重和偏置，使得C(w,b) $\approx$ 0，网络就能很好的工作。</p>
</li>
<li>我们采用<strong>梯度下降</strong>的算法来达到这个目的。</li>
<li>思考：为什么不适用正确分类的图片数量作为评量评估网络的能力？<br>被正确分类的图片数量所关于权重和偏置的函数并不是一个平滑函数，大多数情况下，对权重和偏置做出的微小变动完全不会影响被正确分类的图像数量。 </li>
<li>在该过程我们应该将精力集中在<strong>如何最小化代价函数</strong>，可以忽略MNIST，权重和偏置的等前面所提及的东西。</li>
</ul>
<ul>
<li><p><strong>最小化过程——梯度下降算法</strong><br>假设我们最小化函数C(v)，我们用v代替w和b以强调它可能是任意的函数。为了最小化C(v)我们想象C是一个只有两个变量$v_{1}$和$v_{2}$的函数：<br><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210122144421179.png" alt="image-20210122144421179" style="zoom:80%;"><br>我们要找到C的全局最小值，对于上图我们一眼就能找到最小值。但通常函数C可能是一个复杂的多元函数，看一下就能找到最小值是不可能的。<br>一种方法是：<strong>微积分来解析最小值</strong>。但是变量过多的话就是噩梦，此时使用微积分显然是不可行的。<br>Luckily，<strong>有一种推导法暗示有一种算法能够得到很好的效果</strong>。</p>
<ul>
<li><p>将函数想象成一个山谷，我们想象有一个小球从山谷的斜坡滚落，日常经验告诉我们这个球最终会滚到谷底。</p>
</li>
<li><p>随机给球体一个起始位置，然后模拟球体滚落到谷底的运动。通过计算C的导数来简单模拟——这些导数能够告诉我们山谷中局部“形状”。</p>
</li>
<li><p>当我们在$v_{1}$和$v_{2}$方向分别将球体移动一个很小的量，微积分告诉我们C将会有如下变化:</p>
</li>
<li><script type="math/tex; mode=display">
\Delta C \approx \frac{\partial C}{\partial v_{1}}\Delta v_{1} + \frac{\partial C}{\partial v_{2}}\Delta v_{2}</script></li>
<li><p>寻找一中选择$\Delta v_{1}$和$\Delta v_{2}$使得$\Delta C$为负的方法。先定义$\Delta v$为$v$的变化向量，$\Delta v \equiv (\Delta v_1, \Delta v_2)^T$，T是转置符号。我们也定义C的梯度为偏导数的向量，$(\frac{\partial C}{\partial v_1},\frac{\partial C}{\partial v_2})^T$.我们用$\bigtriangledown C$表示梯度向量，即：<br>$\bigtriangledown C =(\frac{\partial C}{\partial v_1},\frac{\partial C}{\partial v_2})^T$</p>
</li>
<li><p>$\Delta C \approx \bigtriangledown C \cdot \Delta v$ 。$\bigtriangledown C$把$v$的变化关联为C的变化。——func1</p>
</li>
<li><p>我们选取$\Delta v = -\eta \bigtriangledown C$ ，这里的$\eta$是个很小的正数(<strong>学习速率</strong>)。——func2</p>
</li>
<li><p>结合上述两个式子：$\Delta C \approx - \eta \bigtriangledown C \cdot \bigtriangledown C = -\eta||\bigtriangledown C||^2$，由于$||\bigtriangledown C||^2 \geq 0$，这保证了$\Delta C \leq 0$，即，我们按照上面的选取规则$C$会一直减小，不会增大。因此，我们将上面的方程2用于定义球体在梯度下降算法中的“运动定律”。我们用上面的方程计算$\Delta v$，来移动球体的位置$v$：$v \rightarrow v’ = v-\eta \bigtriangledown C$ 。</p>
</li>
<li><p>不断更新规则来计算下一次移动，反复进行，将持续减小C直到获得一个全局最小值。</p>
</li>
<li><p><strong>总结：</strong>重复计算梯度$\bigtriangledown C$，然后沿着相反方向移动，沿着山谷“滚路”。为了是 梯度下降能够正确运行，我们需要选择足够小的学习速率$\eta$使得func2能够得到很好的近似。如果不这样我们会以$\Delta C &gt; 0$结束；同时，也不能使$\eta$太小，否则会使$\Delta v$变化极小，梯度下降算法就会运行的非常慢。</p>
</li>
<li><p><strong>扩展：</strong>函数$C$具有多个变量时</p>
</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
\Delta v=(\Delta v_1,...,\Delta v_m)</script><script type="math/tex; mode=display">
\Delta C \approx \bigtriangledown C \cdot \Delta v</script><script type="math/tex; mode=display">
\bigtriangledown C \equiv (\frac{\part C}{\part v_1},...,\frac{\part C}{\part v_m})^T</script><script type="math/tex; mode=display">
\Delta v = -\eta \bigtriangledown C</script><script type="math/tex; mode=display">
v \rightarrow v' = v-\eta \bigtriangledown C</script><ul>
<li><strong>使用梯度下降算法</strong><ul>
<li>“位置”变量用权重和偏置两个变量代替：$w_k,b_l$。</li>
<li>$w_k \rightarrow w_k’= w_k - \eta \frac {\partial C}{\partial w_k}$</li>
<li>$b_l \rightarrow b_l’= b_l - \eta \frac {\partial C}{\partial b_L}$</li>
<li>问题：$C= \frac{1} n \Sigma_x \bigtriangledown C_x$是普及每个训练样本代价$C_x \equiv \frac {||y(x)-a||^2} {2}$的平均值。在实践中，为了计算梯度$\bigtriangledown C$，我们需要为每个训练输入$x$单独的计算梯度值$\bigtriangledown C_x$，然后求平均值，这蒋辉使学习变得相当缓慢。</li>
<li>方案：<strong>随机梯度下降</strong><br>其思想：随机选取小量训练样本来计算$\bigtriangledown C_x$进而估算梯度$\bigtriangledown C$。,<br>随机选取小量的m个训练输入来工作，我们将其标记为$X_1,…,X_m$ ，称为<strong>小批量数据（mini-batcch)</strong>。假设足够大，我们期望$\bigtriangledown C_{X_j}$的平均值大致等于整个$\bigtriangledown C_x$的平均值，即：$\frac{\Sigma^m_{j=1} \bigtriangledown C_{X_j}}{m} \approx \frac{\Sigma_{x} \bigtriangledown C_{x}}{n} = \bigtriangledown C $<br>$\bigtriangledown C \approx \frac{1} {m} \sum ^m_{j=1} \bigtriangledown C_{X}$ </li>
<li>将其明确地和神经网路的学习联系起来，假设$w_k$和$b_l$表示神经网路中 权重和偏置，梯度下降通过随机地选取并训练输入的小批量数据来工作<br>$w_k \rightarrow w_k’ = w_k - \frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial w_k}$<br>$b_l \rightarrow b_l’ = b_l - \frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial b_l}$<br>其中两个求和符号实在当前小批量数据中的所有训练样本$X_j$上进行的。然后我们再挑选另一随机选定的小批量数据去训练，直到我们用完了所有的训练输入，这被称为<strong>完成了一个训练迭代期(epoch)</strong>,然后我们就会开始 另一个新的训练迭代期。</li>
</ul>
</li>
</ul>
<h2 id="实现我们的网络来分类数字"><a href="#实现我们的网络来分类数字" class="headerlink" title="实现我们的网络来分类数字"></a>实现我们的网络来分类数字</h2><h1 id="反向传播算法如何工作"><a href="#反向传播算法如何工作" class="headerlink" title="反向传播算法如何工作"></a>反向传播算法如何工作</h1><h1 id="改进神经网络的学习方法"><a href="#改进神经网络的学习方法" class="headerlink" title="改进神经网络的学习方法"></a>改进神经网络的学习方法</h1><h1 id="神经网络可以计算任何函数的可视化证明"><a href="#神经网络可以计算任何函数的可视化证明" class="headerlink" title="神经网络可以计算任何函数的可视化证明"></a>神经网络可以计算任何函数的可视化证明</h1><h1 id="深度神经网络为何很难训练"><a href="#深度神经网络为何很难训练" class="headerlink" title="深度神经网络为何很难训练"></a>深度神经网络为何很难训练</h1><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1>]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2021/01/19/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><em>markdown的使用指南及问题解决</em></p>
<a id="more"></a>
<h1 id="markdown-代码"><a href="#markdown-代码" class="headerlink" title="markdown 代码"></a>markdown 代码</h1><ul>
<li><strong>代码</strong> 使用<strong>反引号`</strong>效果如下：</li>
</ul>
<p><code>hello world</code></p>
<ul>
<li><strong>代码区块</strong>使用<strong>4个空格 or 制表符Tab</strong>，效果如下：</li>
</ul>
<ul>
<li><strong>代码区块</strong>还使用<strong>```</strong>包裹一段代码，实例如下：</li>
</ul>
<p>code:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">​<span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">$(document).ready(function () &#123;</span></span><br><span class="line"><span class="string">    alert(&#x27;RUNOOB&#x27;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">​`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="markdown-段落"><a href="#markdown-段落" class="headerlink" title="markdown 段落"></a>markdown 段落</h1><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>在文本的两端加上两条波浪线即可<strong>~~</strong>,实例如下：</p>
<p><code>~~hello,world~~</code></p>
<p><del>hello,world</del></p>
<h2 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h2><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|左对齐|居中|右对齐|</span><br><span class="line">|:-----|:-:|-----:|</span><br><span class="line">|xxxxxx|xxx|xxxxxx|</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">H&lt;sub&gt;2&lt;&#x2F;sub&gt;O  CO&lt;sub&gt;2&lt;&#x2F;sub&gt;</span><br><span class="line">爆米&lt;sup&gt;TM&lt;&#x2F;sup&gt;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p>H<sub>2</sub>O  CO<sub>2</sub></p>
<p>爆米<sup>TM</sup></p>
<h1 id="markdown-特殊字符"><a href="#markdown-特殊字符" class="headerlink" title="markdown 特殊字符"></a>markdown 特殊字符</h1><h2 id="行内添加数学公式"><a href="#行内添加数学公式" class="headerlink" title="行内添加数学公式"></a>行内添加数学公式</h2><p>在文本行内添加数学公式需要开启<strong>内联公式</strong>。</p>
<p><code>文件-&gt;偏好设置-&gt;Markdown</code>中将内联公式勾选。</p>
<script type="math/tex; mode=display">\approx$$              $\approx$





## 插入数学公式

键入$$$$ 后 `Enter` 即可。</script><p>$$</p>
<h2 id="附录：Latex数学符号常用表"><a href="#附录：Latex数学符号常用表" class="headerlink" title="附录：Latex数学符号常用表"></a>附录：Latex数学符号常用表</h2><ul>
<li>上标 <br> <script type="math/tex">a^2</script>    -&gt;   $a^2$<br> <script type="math/tex">a^{222}</script>   -&gt;   $a^{222}$  </li>
<li>下标 <br> <script type="math/tex">A_{b_{c}}</script>   -&gt;   $A_{b_{C}}$ </li>
<li>前角标<br> <script type="math/tex">{^1_2}A{^3_4}</script>   -&gt;   ${^1_2}A{^3_4}$</li>
</ul>
<p><img src="/2021/01/19/markdown%E8%AF%AD%E6%B3%95/20190703164359871.png" alt="img"></p>
<p><img src="/2021/01/19/markdown%E8%AF%AD%E6%B3%95/20190703164424334.png" alt="6"></p>
<p><img src="/2021/01/19/markdown%E8%AF%AD%E6%B3%95/20190703164439850.png" alt="7-9"></p>
<p><img src="/2021/01/19/markdown%E8%AF%AD%E6%B3%95/20190703164500390.png" alt="10-13">    </p>
<h1 id="markdown-特殊操作"><a href="#markdown-特殊操作" class="headerlink" title="markdown 特殊操作"></a>markdown 特殊操作</h1><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p><code>&lt;br/</code>可以实现换行但与Enter效果不同</p>
]]></content>
  </entry>
  <entry>
    <title>hexo-next blog搭建及使用</title>
    <url>/2021/01/19/hexo-next-blog%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>hexo-next blog搭建过程及使用过程中的问题及解决方案</p>
<a id="more"></a>



<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="blog中插入图片"><a href="#blog中插入图片" class="headerlink" title="blog中插入图片"></a>blog中插入图片</h2><p>在配置文件中打开<strong>文章资源文件夹</strong></p>
<p><code>post_asset_folder: true</code></p>
<p>安装插件</p>
<p><code> npm install hexo-asset-image --save</code></p>
<p>打开文件<code>/node_modules/hexo-asset-image/index.js</code>将代码替换为下列代码</p>
<p>（在此感谢Ericam_ 大神：<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/xjm850552586">https://blog.csdn.net/xjm850552586</a>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">var cheerio = require(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line"><span class="keyword">function</span> getPosition(str, m, i) &#123;</span><br><span class="line">  <span class="built_in">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version = String(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(data)&#123;</span><br><span class="line">  var config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        var link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)</span><br><span class="line">       var beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, 1) + 1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       var beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, 3) + 1;</span><br><span class="line">    // In hexo 3.1.1, the permalink of <span class="string">&quot;about&quot;</span> page is like <span class="string">&quot;.../about/index.html&quot;</span>.</span><br><span class="line">    var endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + 1;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(this).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            // For windows style path, we replace <span class="string">&#x27;\&#x27;</span> to <span class="string">&#x27;/&#x27;</span>.</span><br><span class="line">            var src = $(this).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!/http[s]*.*|\/\/.*/.<span class="built_in">test</span>(src) &amp;&amp;</span><br><span class="line">               !/^\s*\//.<span class="built_in">test</span>(src)) &#123;</span><br><span class="line">              // For <span class="string">&quot;about&quot;</span> page, the first part of <span class="string">&quot;src&quot;</span> can<span class="string">&#x27;t be removed.</span></span><br><span class="line"><span class="string">              // In addition, to support multi-level local directory.</span></span><br><span class="line"><span class="string">              var linkArray = link.split(&#x27;</span>/<span class="string">&#x27;).filter(function(elem)&#123;</span></span><br><span class="line"><span class="string">                return elem != &#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">              &#125;);</span></span><br><span class="line"><span class="string">              var srcArray = src.split(&#x27;</span>/<span class="string">&#x27;).filter(function(elem)&#123;</span></span><br><span class="line"><span class="string">                return elem != &#x27;</span><span class="string">&#x27; &amp;&amp; elem != &#x27;</span>.<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">              &#125;);</span></span><br><span class="line"><span class="string">              if(srcArray.length &gt; 1)</span></span><br><span class="line"><span class="string">                srcArray.shift();</span></span><br><span class="line"><span class="string">              src = srcArray.join(&#x27;</span>/<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">              $(this).attr(&#x27;</span>src<span class="string">&#x27;, config.root + link + src);</span></span><br><span class="line"><span class="string">              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;else&#123;</span></span><br><span class="line"><span class="string">            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span></span><br><span class="line"><span class="string">            console.info&amp;&amp;console.info($(this));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">      data[key] = $.html();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>


<p>Typora对于插入图片的支持做得非常好，在<code>文件-&gt;偏好设置-&gt;图像</code>中选择<code>复制到指定的路径</code> <code>./$&#123;filename&#125;</code> </p>
<p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p>
<p>如复制网络路径的图片<code>https://...../image.jpg</code>粘贴到Typora中叫<code>文章名</code>的文章后，图片会自动变为<code>![](文章名/image.jpg)</code>。</p>
<p>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的<code>文件名/</code>。不慌，也很简单。</p>
<p>在Typora编辑器中，使用<code>&lt;C-f&gt;</code>快捷键，将所有的<code>文章名/</code>替换为空即可删除。</p>
<p><img src="/2021/01/19/hexo-next-blog%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/among-us-3840x2160-artwork-4k-23114-1611067673187.jpg" alt="among-us-3840x2160-artwork-4k-23114"></p>
]]></content>
  </entry>
  <entry>
    <title>python学习记录</title>
    <url>/2021/01/21/python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><em>记录python的学习过程。</em></p>
<a id="more"></a>
<h1 id="Python3-环境搭建"><a href="#Python3-环境搭建" class="headerlink" title="Python3 环境搭建"></a>Python3 环境搭建</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><h2 id="运行python"><a href="#运行python" class="headerlink" title="运行python"></a>运行python</h2><h1 id="Python基本语法"><a href="#Python基本语法" class="headerlink" title="Python基本语法"></a>Python基本语法</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>字母或下划线(_)开头</li>
<li>字母下划线数字组成</li>
<li>对大小写敏感</li>
<li>在PYthon3中可以用中文作为变量名，非ASCII码也是允许的</li>
</ul>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class="line">[<span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, <span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>单行注释以<strong>#</strong>开头</li>
</ul>
<ul>
<li>多行注释可以使用多个<strong>#</strong>号，或者用<strong>```</strong>和<strong>“””</strong>包裹</li>
</ul>
<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python最具特色的就是<strong>缩进来表示代码块，而不是使用大括号</strong><code>&#123;&#125;</code></p>
<p>所进的空格数是可变的，但是<strong>同一个代码块的语句必须包含相同的空格数</strong></p>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>python通常是一行写完一条语句，但是如果语句过长我们可以<strong>使用反斜杠()来实现多行语句</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>
<p><strong>在[],{},()中的多行语句不需要使用</strong></p>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p><strong>记住：</strong>空行也是程序代码的一部分。</p>
<h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><p>执行<code>input()</code>函数后等待用户键入，按下Enter后结束键入</p>
<h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>python可以在一行中使用多条语句，语句之间用<code>分号;</code>分割</p>
<h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像<code>if``while``def``class</code>这样的复合语句，首行以关键字开始，以：号结束，改行之后的一行或者多行构成代码组。我们将首行及后面的代码组称为一个子句(clasuse)</p>
<h2 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h2><p><code>print</code>默认输出是换行的，如果实现不换行的输出需要在变量末尾加上<code>end=&quot;&quot;</code></p>
<h2 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h2><p>用<code>import</code>或者<code>from..import</code>来导入相应的模块</p>
<p>将整个模块(somemodule)导入：<code>import somemodule</code></p>
<p>从某个模块中导入某个函数：<code>from somemodule import somefunction</code></p>
<p>从某个模块中导入多个函数：<code>from somemodule import firstfunc, secondfunc, thirdfunc</code></p>
<p>将某个模块中的全部函数导入：<code>from somemoudle import *</code></p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>python可以使用<code>-h</code>参数查看各参数帮助信息</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><strong>python中的变量不需要声明，每个变量在使用前都必须赋值，变量被赋值后该变量才会被创建。</strong></p>
<p><strong>在python中，变量就是变量，没有类型，我们所说的“类型”是变量所指的内存中对象的类型。</strong></p>
<p><code>等号 =</code> :用来给变量赋值，其左边是一个变量名，右边是存储在变量中的值。</p>
<h2 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h2><p>Python允许同时为多个变量赋值：</p>
<ul>
<li><code>a = b = c = 1</code>，创建一个整型对象，值为1，三个变量被赋予相同的数值。</li>
<li><code>a, b, c = 1, 2, &quot;hello&quot;</code>，两个整型对象1和2分配给a和b，字符串对象“hello”分配给变量c。</li>
</ul>
<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<p><strong>不可变数据</strong>：Number，String，Tuple；</p>
<p><strong>可变数据</strong>：List，Dictionary，Set。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java与Android移动应用开发</title>
    <url>/2021/03/03/Java%E4%B8%8EAndroid%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p><em>java学习之路——勇往直前吧！</em></p>
<a id="more"></a>
<h1 id="Java开发基础"><a href="#Java开发基础" class="headerlink" title="Java开发基础"></a>Java开发基础</h1><h2 id="语句和语句块"><a href="#语句和语句块" class="headerlink" title="语句和语句块"></a>语句和语句块</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> firstdemo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;HelloJava&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>package</strong>语句：代码定义在哪个包中，结尾要有<strong>;</strong> </li>
<li><strong>import</strong>语句：引用其他包中的资源</li>
<li><strong>public</strong>和<strong>class</strong>关键字：定义一个类，使用 <strong>{}</strong> 定义类的主体部分，称为代码块</li>
<li><strong>main()</strong>：类中可能会包含很多成员，main()方法是程序执行的入口，其主体同样用 <strong>{}</strong> 定义</li>
<li><strong>System.out.println()方法</strong>：输出一些内容</li>
</ul>
<h2 id="注释内容"><a href="#注释内容" class="headerlink" title="注释内容"></a>注释内容</h2><p>Java中，有四种注释方法：</p>
<p><strong>行注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注释内容</span></span><br><span class="line">System.out.println(<span class="string">&quot;HelloJava&quot;</span>);  <span class="comment">//注释内容</span></span><br></pre></td></tr></table></figure>
<p><strong>块注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>块注释中使用@</strong></p>
<p>用@符号表示的指令，可以通过javadoc命令创建HTML文档。</p>
<p><strong>文档注释</strong></p>
<p><code>/**      */</code></p>
<h2 id="保留字标识符"><a href="#保留字标识符" class="headerlink" title="保留字标识符"></a>保留字标识符</h2><p><strong>标识符规范</strong>：可以使用字母、下划线、$符号和数字等，但是第一个字符不能为数字。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><strong>最终变量（常量）</strong>：在其类型前使用<strong>final</strong>关键字。</p>
<p><strong>定义规范</strong>：同时定义多个相同类型变量时可以使用<code>,</code>分隔，并可以分别赋值。</p>
<p><strong>不同类型的数据之间进行运算</strong>：</p>
<ul>
<li>基本类型之间转化：除boolean自动进行转换：<code>byte,short,char – int–long–float–double</code>。即表述范围小的可以自动转化为表述范围大的。</li>
<li>基本类型和String：基本类型与String之间的运算，会转换成String类型。</li>
</ul>
<p><strong>byte类型数据是有符号的</strong>，当数据为负数时，其二进制实际上是其绝对值的补码形式，。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> x = <span class="number">0b00000010</span>;</span><br><span class="line">System.out.println(~x);  </span><br><span class="line"><span class="comment">//-3, 0b11111101</span></span><br><span class="line"><span class="comment">//整数3的8位二进制形式为00000011</span></span><br><span class="line"><span class="comment">//补码的计算是按位取反后加1</span></span><br><span class="line"><span class="comment">//3的补码为11111100+1=11111101</span></span><br><span class="line"><span class="comment">//故0b11111101表示-3</span></span><br></pre></td></tr></table></figure>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><p>默认为十进制，但也可以使用其他进制。</p>
<ul>
<li>0开头的定义为八进制，<code>020</code>表示十进制数16.</li>
<li>0x开头定义为十六进制，<code>0xf</code>表示十进制数15。</li>
<li>0b开头定义为二进制，<code>0b0101</code>表示十进制数5。</li>
</ul>
<h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><ul>
<li>可以使用：+、-、*、/和%运算符。</li>
<li><p>整数运算的结果仍为整数，<strong>如果运算数的类型不一样，则统一转化为取值范围较大的类型，然后进行计算</strong>。</p>
</li>
<li><p>整数的除法和取余运算如果右运算数为0会产生错误。</p>
</li>
</ul>
<h4 id="增量与减量运算"><a href="#增量与减量运算" class="headerlink" title="增量与减量运算"></a>增量与减量运算</h4><p>对于前增量和后增量操作，如果只需要使用变量运算后的值则他们是一样的；但是在使用运算表达式的值时，则有区别。</p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h5 id="逻辑位运算"><a href="#逻辑位运算" class="headerlink" title="逻辑位运算"></a>逻辑位运算</h5><p>对操作数的二进制位进行逻辑运算。</p>
<ul>
<li><p><strong>&amp;</strong>：与运算，当两个二进制位数据都为1时返回1，否则为0</p>
</li>
<li><p><strong>|</strong>：或运算，当两个二进制位数据都为0时返回0，否则为1</p>
</li>
<li><strong>~</strong>：取反运算，二进制数据为1时返回0，为0时返回1</li>
<li><strong>^</strong>：异或运算，当两个二进制位数据相同时返回0，不同时返回1</li>
</ul>
<p>在实际开发工作中，逻辑位运算经常进行一些标识数据的比较工作。</p>
<h5 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h5><ul>
<li><strong>&lt;&lt;</strong>：位左移运算，二进制位会向左移动，低位补0。<strong>当整数x进行左移n位运算时，就是在执行：x * (2 ^ n)</strong>。如果左移运算超出类型支持的位数，超出部分会丢失，即数据溢出。</li>
<li><strong>&gt;&gt;</strong>：位右移运算，二进制位会向右移动，<strong>符号位不动，右移空出的高位要补上与符号位相同的数据，执行x / (2 ^ n)</strong>。</li>
<li><strong>&gt;&gt;&gt;</strong>：无符号右移运算，使用时不考虑符号位，整体右移且高位补0。</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数指可以处理小数部分的数据类型。</p>
<p>支持运算：算术运算和增量减量，但不能进行位运算。</p>
<ul>
<li><strong>double双精度浮点数</strong>：64位。含有小数部分的数据默认类型为double。如果需要明确指出数据是double类型，可以使用d或D后缀。</li>
<li><strong>float单精度浮点数</strong>：32位。使用f或F后缀。</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>把一个取值范围小的类型转化为取值范围大的类型。</p>
<p>不同数据类型进行运算时会进行隐形转换。</p>
<h3 id="非隐式转换"><a href="#非隐式转换" class="headerlink" title="非隐式转换"></a>非隐式转换</h3><p>把一个取值范围大的类型转化为取值范围小的类型。</p>
<p>这是不能被正确执行的，如果确实需要这种转换操作，就必须进行强制转换。在需要转换的数据前使用<code>()</code>指定目标类型。当数据超出目标类型的取值范围，会进行截断操作，数据内容会发生改变。浮点数转化为整数时会丢失小数部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> y = (<span class="keyword">int</span>) x;</span><br></pre></td></tr></table></figure>
<p> char类型</p>
<p>用于处理Unicode字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(ch);  <span class="comment">//A</span></span><br><span class="line">System.out.println( (<span class="keyword">int</span>) ch ); <span class="comment">//65 A的ASCII码</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>) <span class="number">65</span>);  <span class="comment">//A</span></span><br></pre></td></tr></table></figure>
<p>Java代码文件完全支持Unicode字符，也就是说可以使用中文来作为变量名。</p>
<p><strong>转义字符</strong></p>
<ul>
<li><code>\n</code></li>
<li><code>\r</code></li>
<li><code>\f</code></li>
<li><code>\b</code></li>
<li><code>\t</code></li>
<li><code>\\</code></li>
<li><code>\&quot;</code></li>
<li><code>\&#39;</code></li>
<li><code>\uxxx</code></li>
</ul>
<h2 id="bioolean类型"><a href="#bioolean类型" class="headerlink" title="bioolean类型"></a>bioolean类型</h2><p>布尔类型或逻辑型</p>
<ul>
<li>&amp;&amp;</li>
<li>||</li>
<li>!</li>
</ul>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举是一种自定义的数据类型，其中定义了可用的数据（枚举值）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ESex</span> </span>&#123;unknow, male, female&#125;;</span><br><span class="line"><span class="comment">//enum关键字后指定枚举类型的名称。枚举成员定义在&#123;&#125;中，用逗号分隔</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args)</span> </span>&#123;</span><br><span class="line">    ESex sex = ESex.male;</span><br><span class="line">    System.out.println(sex); <span class="comment">//male</span></span><br><span class="line">    System.out.println(sex.ordinal());  <span class="comment">//1</span></span><br><span class="line">    System.out.println(ESex.values()[<span class="number">2</span>]); <span class="comment">//female</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型的本质：每个成员都会有一个整数索引值，第一个成员的索引值位0，以此类推。当枚举类型和整数类型进行转换时，实际上就是在成员索引值和成员名称之间进行转换。</p>
<h2 id="代码的组织和应用程序的基本结构"><a href="#代码的组织和应用程序的基本结构" class="headerlink" title="代码的组织和应用程序的基本结构"></a>代码的组织和应用程序的基本结构</h2><p>每一个发布项目都应该有一个唯一的包（package）名。</p>
<p>习惯的方法：反向域名+应用名</p>
<p>由一个或多个类组成，其中必须有一个定义了main()方法。</p>
<p>程序的源代码结构<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package</span><br><span class="line">import</span><br><span class="line">---------------</span><br><span class="line">class 类1&#123;</span><br><span class="line">    ----------</span><br><span class="line">    方法</span><br><span class="line">    ----------</span><br><span class="line">    变量</span><br><span class="line">    ----------</span><br><span class="line">&#125;</span><br><span class="line">class 类2&#123;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br><span class="line">..............</span><br></pre></td></tr></table></figure></p>
<ul>
<li>每个源文件中只能有一个类或接口是公共的</li>
<li>编译后每个类产生一个.class文件</li>
<li>包是每个java系统用来组织类的组织</li>
<li>编程只能在方法中进行</li>
</ul>
<h1 id="面向对象编程-OPP"><a href="#面向对象编程-OPP" class="headerlink" title="面向对象编程 OPP"></a>面向对象编程 OPP</h1><p>面向对象编程就是将一系列数据及其操作进行封装，让数据更直观、代码维护更高效。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类（class）是一种更加复杂的数据类型，它主要包括两种成员<strong>字段(field)</strong> 和 <strong>方法(method)</strong>。字段用来存储数据，方法则定义数据的一些列操作。</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><h4 id="类的定义语法"><a href="#类的定义语法" class="headerlink" title="类的定义语法"></a>类的定义语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> firstdemo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CAuto</span> </span>&#123;</span><br><span class="line"><span class="comment">//[类的修饰符] class 类名</span></span><br><span class="line">  <span class="comment">//[extends 父类名] 仅可以继承一个父类</span></span><br><span class="line">  <span class="comment">//[implments 接口名] 可以有多个接口</span></span><br><span class="line">    <span class="keyword">public</span> String model = <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> doors = <span class="number">4</span>;</span><br><span class="line">  <span class="comment">//成员变量定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveTO</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        String s = String.format(<span class="string">&quot;%s 移动到 (%d, %d)&quot;</span>, model,x,y);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>model字段，表示车的型号，定义为String类型，默认为空字符串。</li>
<li>doors字段，表示车门的数量，定义为int类型，默认为4。</li>
<li>moveTO()方法，用于显示车的移动信息。</li>
<li>String.format()方法，将各种类型的数据组合为字符串类型。</li>
<li>类修饰符：<ul>
<li>public:允许其他类访问，一个源文件仅可以有一个public类。</li>
<li>abstract：没有实例的抽象类。</li>
<li>final：不能再被拓展，不能有子类；易于安全的实现。<h4 id="类的成员变量的声明"><a href="#类的成员变量的声明" class="headerlink" title="类的成员变量的声明"></a>类的成员变量的声明</h4><code>[public|protected|private] [static|] [final] [transient] [volatile]</code><br><strong>static</strong>：类成员变量，对所有的实例一致<br><strong>final</strong>：数值不变常量，定义同时需要进行初始化<br><strong>transient</strong>：暂时性变量，用于对象存档<br><strong>volatile</strong>：易变变量，用于并发线程共享</li>
</ul>
</li>
</ul>
<h4 id="类的方法声明"><a href="#类的方法声明" class="headerlink" title="类的方法声明"></a>类的方法声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">public</span>|<span class="keyword">protected</span>|<span class="keyword">private</span>] [<span class="keyword">static</span>|] [<span class="keyword">final</span>] [<span class="keyword">abstract</span>] [<span class="keyword">native</span>] [<span class="keyword">synchronized</span>] 返回类型 方法名 (参数列表)</span><br><span class="line">[ <span class="keyword">throws</span> 例外名]</span><br><span class="line">&#123;</span><br><span class="line">    方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>static:静态方法，在方法体中只能使用静态方法和静态变量</li>
</ul>
<h3 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h3><ul>
<li><p>定义此类型的“变量”：<code>CAuto auto</code><br>auto称为类的一个<strong>实例（instance）或者CAuto类型的对象</strong>，简称为auto对象。此时auto对象暂时还不能使用，因为它还没有实例化，其值默认为null。</p>
</li>
<li><p>对象的实例化：<code>CAuto auto = new CAuto();</code><br>实例化一个对象需要使用<strong>new</strong>关键字。</p>
</li>
<li><p>应用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">auto.model = <span class="string">&quot;x9&quot;</span>;</span><br><span class="line">auto.moveTo(<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>代码中，<strong>圆点运算符（.）</strong>用来调用对象的字段和方法。</p>
</li>
</ul>
<h3 id="构造函数和对象释放"><a href="#构造函数和对象释放" class="headerlink" title="构造函数和对象释放"></a>构造函数和对象释放</h3><p><code>CAuto auto = new CAuto();</code><br>代码中<code>CAuto()</code>是方法，为CAuto类的构造函数。类在创建时会包含一个空的构造函数。</p>
<p>构造函数看上去和方法差不多，但是他的名称与类相同，而且不需要定义返回值类型。一个类可以定义多个构造函数，<strong>只要它们的参数设置能够有效区分就可以</strong>。</p>
<p><strong>构造函数链</strong>：减少重复代码，提高维护效率<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CAuto</span><span class="params">(String m, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    model = m;</span><br><span class="line">    doors = d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CAuto</span><span class="params">(String m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(m, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CAuto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>this</strong>：此关键字指当前实例。当运行构造函数2时会调用当前实例的构造函数1，同理运行构造函数3时会调用构造函数2进而调用构造函数1。<br><strong>super</strong>：对父类构造方法的调用</p>
<p><strong>对象释放</strong>：Java运行环境可以自动回收不再使用的对象，大多数情况下不需要开发者编写代码进行处理。但是当对象中使用了一些外部资源时，就应该保证这些资源能够正确地关闭。</p>
<h3 id="getter-和setter-方法"><a href="#getter-和setter-方法" class="headerlink" title="getter()和setter()方法"></a>getter()和setter()方法</h3><p>用这两种方法控制字段数据的读取和设置操作。对私有成员变量访问和修改的方法。</p>
<h3 id="静态成员与静态初始化"><a href="#静态成员与静态初始化" class="headerlink" title="静态成员与静态初始化"></a>静态成员与静态初始化</h3><p>类中创建的字段和方法都必须使用类的实例来访问，称为类的实例成员。不同于类的实例成员，静态成员可以使用类的名称直接访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> example = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果需要对静态成员初始化，可以再类中使用<strong>static</strong>语句定义一个结构体来完成，<strong>结构体中的代码会在第一次调用静态成员时执行一次</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="comment">//静态初始化结构</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态初始化&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;修饰符&gt; &lt;返回值类型&gt; &lt;方法名&gt;(参数列表) &#123;</span><br><span class="line">  &lt;方法体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修饰符：确定方法的访问形式与访问级别</p>
<h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>方法中需要使用零个或多个相同类型的参数，可以通过可变长(variable-length)参数简化参数定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(String... names)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(String s : names) &#123;</span><br><span class="line">    System.out.println(s + <span class="string">&quot;加入&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在String后面使用<strong>…运算符</strong>，调用join()方法时就可以使用零个或者多个String类型的参数了。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载：多个方法具有相同的名称，但因为不同的参数类型或者个数可以明显区分，构造函数就是典型的重载函数。</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类名 <span class="keyword">extends</span> 超类名 </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类：继承后得到的类<br>超类：被继承的类，又称为基类或者父类<br>继承范围：无参数的构造函数和非私有成员<br>final关键字：在定义类时使用该关键字则该类不可被继承<br>继承唯一：子类只能有一个直接超类</p>
<h3 id="java-lang-Object类"><a href="#java-lang-Object类" class="headerlink" title="java.lang.Object类"></a>java.lang.Object类</h3><ul>
<li><p>Object类位于包java.lang包中，java.lang包包含着Java最基础和核心的类，编译时会自动导入。</p>
</li>
<li><p>Object类是Java类的鼻祖，每个类都是用Object类作为超类。因此我们可以使用一些Object类中的非私有成员在所有类中。</p>
</li>
</ul>
<h3 id="拓展和重写"><a href="#拓展和重写" class="headerlink" title="拓展和重写"></a>拓展和重写</h3><p>子类如果单纯地继承超类那么它的意义不大，事实上，子类可以拓展超类的功能，或者对超类的功能进行重写。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>如果在子类中没有定义构造函数，默认会继承超类中的无参数构造函数；<br>如果子类中定义了一个构造函数，就不能直接使用超类的构造函数创建对象了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超类</span></span><br><span class="line"><span class="keyword">package</span> src;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String inname)</span></span>&#123;</span><br><span class="line">        name = inname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;unknow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">package</span> src;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类中没有定义构造函数会默认继承超类的无参数构造函数，name=unknow</span></span><br></pre></td></tr></table></figure>
<p>超类中创建的构造函数并不是没有用武之地了，可以在子类中加个“外壳”用来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超类</span></span><br><span class="line"><span class="keyword">package</span> src;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String inname)</span></span>&#123;</span><br><span class="line">        name = inname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;unknow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">package</span> src;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>super关键字</strong>：调用超类的构造函数<br>使用this和super关键字可以合理地重用当前类或者超类中的构造函数。</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>子类如果需要重新实现超类中的成员，可以直接定义。还可以使用super关键字访问超类中的成员。</p>
<h3 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h3><ul>
<li>private：私有，只能在其定义的类中使用</li>
<li>protected：受保护，在其定义的类和子类中访问</li>
<li>public：公共，可以供类外部代码调用</li>
<li>default：默认访问级别，可在类外部调用，只能在其定义的包中使用。</li>
</ul>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>用于判断一个对象是否为某个类的实例。<br>A为B的一个实例；B为C的子类。<br>| 实例    | 类 | 返回值 |<br>| :——-: | :—-: | :——-: |<br>| A instanceof | B | true |<br>| A instanceof | C| true |<br>| A instanceof | Object | true |</p>
<h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><ul>
<li>定义方法时使用abstract关键字，方法就定义为抽象方法。</li>
<li>抽象方法并不需要方法体，它必须由类的子类来实现。</li>
<li>当一个类中包含抽象方法时，这个类应定义为抽象类。</li>
<li>抽象类像是标准的制定者，它可以定义一系列抽象方法，然后让其子类去具体实现，从而创建具有相同成员但实现各有不同的类型。</li>
</ul>
<h2 id="数据类型处理"><a href="#数据类型处理" class="headerlink" title="数据类型处理"></a>数据类型处理</h2><h3 id="基本数据类型和包装类"><a href="#基本数据类型和包装类" class="headerlink" title="基本数据类型和包装类"></a>基本数据类型和包装类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">基本数据类型</th>
<th style="text-align:center">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">java.lang.Byte</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">java.lang.Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">java.lang.Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">java.lang.Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">java.lang.Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">java.lang.Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">java.lang.Double</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">java.lang.Char</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">java.lang.Boolean</td>
</tr>
</tbody>
</table>
</div>
<p>当基本数据类型需要面向对象操作时可以将其转化为对象来使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer objx = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">    System.out.println(objx.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Integer类的构造函数代入一个整数，从而创建一个值为10的Integer对象。然后，通过toString()方法显示其内容。、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer objx = <span class="number">10</span>;</span><br><span class="line">System.out.println(objx.toString());</span><br></pre></td></tr></table></figure>
<p>这里，直接将整数赋值给Integer类型的objx，编译器会自动完成转换工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer objx = <span class="number">10</span>;</span><br><span class="line">    System.out.println(objx.intValue());     <span class="comment">//10</span></span><br><span class="line">    System.out.println(objx.floatValue());;  <span class="comment">//10.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>intValue()和floatValue()方法可以将objx对象中的数据转化为整数和浮点数。</p>
<h3 id="数据的传递"><a href="#数据的传递" class="headerlink" title="数据的传递"></a>数据的传递</h3><p>基本数据类型称为值类型，而所有的类称为引用类型。</p>
<ul>
<li>值类型的参数在传递过程中会产生一个副本，其本身不会改变。</li>
<li>引用类型在传递时会传递其对象位于内存中的位置，作为参数时自身可能会发生改变。</li>
<li>String类型，引用类型中的异类。其用于处理不可变字符串类型，即String对象的内容一旦确定就不能改变，对于字符串内容的任何操作，都会生成一个新的字符串对象。</li>
</ul>
<h3 id="类型的动态处理"><a href="#类型的动态处理" class="headerlink" title="类型的动态处理"></a>类型的动态处理</h3><p>Object类的常用成员：</p>
<ul>
<li><strong>eauals()</strong>：与参数指定的对象进行比较，当两个对象是同一引用时返回true。</li>
<li><strong>toString()</strong>：返回对象的文本描述。</li>
<li><strong>getClass()</strong>：返回一个Class类型的对象，即对象类型的描述对象。</li>
</ul>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始条件; 执行条件; 循环控制变量循环后变化)&#123;</span><br><span class="line">    代码块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯</title>
    <url>/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/</url>
    <content><![CDATA[<p><em>2021年蓝桥杯准备笔记。</em><br><a id="more"></a></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>末尾以<code>\0</code>结束的字符型数组称为字符串。值得强调的是只有以<code>\0</code>结束的才算字符串，否则只能算字符数组。</p>
<p><strong>strcpy()</strong>函数：复制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;hellowlrld&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(name, str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name;</span><br></pre></td></tr></table></figure>
<p><strong>strcat</strong>函数：拼接</p>
<p><strong>strcmp()</strong>函数：比较，如果两个字符串完全相同返回0.从第一个字符开始逐字符比较ASCII码，返回第一个不相同字符ASCII码差值。</p>
<p><strong>strlen()</strong>函数；返回字符串长度</p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>位运算的奇巧淫技：</p>
<ul>
<li>判断奇偶性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x &amp; <span class="number">1</span> == <span class="number">1</span>; <span class="comment">//奇数：奇数二进制最低位必为1</span></span><br><span class="line">x &amp; <span class="number">1</span> == <span class="number">0</span>; <span class="comment">//偶数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取二进制位是1还是0：通过左移1的位置，原理同上</li>
<li>交换两个整型变量的值：做三次异或操作</li>
<li>不用判断语句求整数的绝对值</li>
<li>拓展：异或操作可以理解为不进位加法</li>
</ul>
<p>问题：</p>
<ul>
<li>将1-1000这些个数放在一个1001个元素的数组中，只有唯一的一个元素重复。每个元素只能访问一次，设计一个算法找出这个数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">方案<span class="number">1</span>：</span><br><span class="line"><span class="comment">// A ^ A == 0;</span></span><br><span class="line"><span class="comment">// B ^ 0 == B;</span></span><br><span class="line"><span class="comment">// A ^ B ^ C == A ^ C ^ B </span></span><br><span class="line"><span class="comment">//满足交换律：本质看同一位01的个数为奇数还是偶数</span></span><br><span class="line"><span class="number">1</span>^<span class="number">2</span>^...^<span class="number">1001</span> ^(<span class="number">1</span>^<span class="number">2</span>^..<span class="number">.1000</span>);</span><br><span class="line"></span><br><span class="line">方案<span class="number">2</span>；</span><br><span class="line">扫描技术法：开一个数组，用存数数组的元素作为该数组的下标，没出现一次便加一操作</span><br></pre></td></tr></table></figure>
<ul>
<li>输入一个整数，输出该数二进制中1的个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">设输入量为x</span><br><span class="line">方案<span class="number">1</span>：</span><br><span class="line">做&amp;运算并向左移动<span class="number">1</span>的位置</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    x &amp; i != <span class="number">0</span>; <span class="comment">//此时计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方案<span class="number">2</span>；右移x</span><br><span class="line"></span><br><span class="line">方案<span class="number">3</span>：经典：消掉<span class="number">1</span></span><br><span class="line">假设：<span class="number">100100</span>   将其进行<span class="number">-1</span>操作</span><br><span class="line">     -     <span class="number">1</span></span><br><span class="line">      <span class="number">100011</span>   变化由于借位原为<span class="number">1</span>的最低为变为<span class="number">0</span>其后<span class="number">0</span>变为<span class="number">1</span></span><br><span class="line"></span><br><span class="line">      <span class="number">100100</span></span><br><span class="line">    &amp; <span class="number">100011</span></span><br><span class="line">      <span class="number">100000</span>  继续进行<span class="number">-1</span>作与运算看做多少次后为<span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用一条语句判断一个整数是不是2的整数次方</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">观察<span class="number">2</span>的整数次方<span class="number">2</span>进制：<span class="number">1</span>，<span class="number">10</span>，<span class="number">100</span>，<span class="number">1000</span></span><br><span class="line">总结：只有一个<span class="number">1</span></span><br><span class="line">结合上题方案<span class="number">3</span>，有一个<span class="number">1</span>只能做一次减一作与操作</span><br><span class="line"><span class="keyword">if</span>(x&amp;(x<span class="number">-1</span>)==<span class="number">0</span>) <span class="comment">//便为2整数次方</span></span><br></pre></td></tr></table></figure>
<h1 id="C-笔记"><a href="#C-笔记" class="headerlink" title="C++笔记"></a>C++笔记</h1><p>warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="string">&quot;abc&quot;</span>; <span class="comment">//warning</span></span><br><span class="line"><span class="keyword">char</span>* p = (<span class="keyword">char</span>*)<span class="string">&quot;abc&quot;</span>;  <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *p = <span class="string">&quot;abc&quot;</span>;　　<span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>原因解释：</p>
<p>学习c或者c++的时候都知道，如果在赋值操作的时候，等号两边的变量类型不一样，那么编译器会进行一种叫做 implicit conversion 的操作来使得变量可以被赋值。<br>在上面的表达式中等号右边的”abc”是一个不变常量，在c++中叫做string literal，type是const char *，而p则是一个char指针。如果强行赋值会发生什么呢？没错，就是将右边的常量强制类型转换成一个指针，结果就是我们在修改一个const常量。编译运行的结果会因编译器和操作系统共同决定，有的编译器会通过，有的会抛异常，就算过了也可能因为操作系统的敏感性而被杀掉。<br>像这种直接将string literal 赋值给指针的操作被开发者们认为是deprecated，只不过由于以前很多代码都有这种习惯，为了兼容，就保留下来了。</p>
]]></content>
  </entry>
  <entry>
    <title>vscode使用指南</title>
    <url>/2021/03/05/vscode%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
