<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>神经网络与深度学习-note</title>
    <url>/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/</url>
    <content><![CDATA[<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120081213727.png" alt="image-20210120081213727"></p>
<p><em>记录Michael Nielsen 的《神经网络与深度学习》学习过程。</em></p>
<a id="more"></a>
<h1 id="使用神经网络识别手写数字"><a href="#使用神经网络识别手写数字" class="headerlink" title="使用神经网络识别手写数字"></a>使用神经网络识别手写数字</h1><p>识别数字主要思想：获取大量的手写数字，常称作训练样本，然后开发出一个可以从这些训练样本中进行学习的系统。即神经网络使用样本来自动推断出识别手写数字的规则。</p>
<p>提高准确性：通过增加训练样本的数量，神经网络可以学到更多关于手写数字的知识。</p>
<h2 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h2><h3 id="感知器的定义"><a href="#感知器的定义" class="headerlink" title="感知器的定义"></a>感知器的定义</h3><ul>
<li>依据权重来做出决定的设备。</li>
<li>接收几个二进制输入，产生一个二进制输出</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120074657848.png" alt="image-20210120074657848"></p>
<ul>
<li><p>引入<strong>权重</strong>规则，用其表示相应输入对于输出的重要性。</p>
</li>
<li><p><strong>阈(yu)值</strong>是一个实数，一个神经元的参数。神经元的输出(0 or 1)由分配权重后的总和与阈值的大小关系决定。</p>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120075501785.png" alt></p>
</li>
</ul>
<h3 id="简化感知器的数学描述"><a href="#简化感知器的数学描述" class="headerlink" title="简化感知器的数学描述"></a>简化感知器的数学描述</h3><ul>
<li><p>第一个变动是用w和x对应权重和输入的向量的点乘。</p>
</li>
<li><p>第二个变动用感知器的偏置b=-threshold代替。</p>
</li>
<li><p><strong>偏置</strong>：一种标识让感知器输出1(激活感知器)有多容易的估算。偏置非常大时输出1是很容易的，偏置非常小时输出1则很困难。</p>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120092559889.png" alt></p>
</li>
</ul>
<h3 id="感知器网络"><a href="#感知器网络" class="headerlink" title="感知器网络"></a>感知器网络</h3><ul>
<li><p>第一层感知器——通过权衡输入依据做出三个简单决定。</p>
</li>
<li><p>第二层感知器——权衡第一层的决策结果并作出决定。以这种方式，二层感知器可以比一层感知器做出更复杂和抽象的决策。</p>
</li>
<li><strong>一个感知器只有一个输出</strong>，下图箭头仅仅便于说明一个一个感知器的输出被用于多个感知器。</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120093803752.png" alt="image-20210120093803752" style="zoom: 67%;"></p>
<h3 id="感知器计算基本逻辑的功能"><a href="#感知器计算基本逻辑的功能" class="headerlink" title="感知器计算基本逻辑的功能"></a>感知器计算基本逻辑的功能</h3><ul>
<li><p>运算基础，例如“<strong>与</strong>”，“<strong>或</strong>”和“<strong>与非</strong></p>
</li>
<li><p>与非门感知器：输入00产生1，输入11产生0</p>
</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120103347029.png" alt="image-20210120103347029"></p>
<ul>
<li>与非门是通用运算，以此为基础我们可以用感知器网络来计算任何逻辑功能</li>
<li>构建一个电路将两个二进制数相加</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120115000598.png" alt="image-20210120115000598" style="zoom:80%;"></p>
<ul>
<li>将与非门替换为感知器</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120115226182.png" alt="image-20210120115226182" style="zoom:67%;"></p>
<ul>
<li>最左边感知器的输出被两次作为底部感知器的输入。进而我们可以简单把两条线合并为到一个权重为-4的连接</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120115424951.png" alt="image-20210120115424951" style="zoom: 67%;"></p>
<ul>
<li><strong>输入层</strong>：将<code>x1</code> <code>x2</code>这样的感知器网路左边的浮动变量可以画一层额外的感知器来方便输入编码</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120115831884.png" alt="image-20210120115831884" style="zoom:67%;"></p>
<ul>
<li>输入感知器：可以完全不将其看作感知器，而是简单的定义为输出期望值的特殊单元。</li>
</ul>
<h2 id="S型神经元"><a href="#S型神经元" class="headerlink" title="S型神经元"></a>S型神经元</h2><h3 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h3><p>自动调节人工神经元的权重和偏置</p>
<ul>
<li>学习过程：如果对权重(or 偏置)的微小的改动能够仅仅引起输出的微小变化，那么我们可以利用这一事实来修改权重和偏置，让我们的网络表现得像我们想要的那样。假设网络误将一个”9“识别为”8“。我们能够计算出对权重和偏置的微小改动，使网络将其正确识别。我们重复这个工作，反复修改权重和偏置来产生更好的输出。</li>
<li>问题：网络中单个感知器的权重或偏置的微小改动有时候会引起那个感知器的输出完全翻转，如0变到1。这样的翻转可能接下来引起其余网路的行为以极其复杂的方式完全改变。虽然”9“可能别正确分类，网络在其他图像上的行为很可能以一些很难控制的方式被完全改变。这使得逐步修改权重和偏置来让网络接近期望行为变得困难。</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120173437965.png" alt="image-20210120173437965" style="zoom:80%;"></p>
<ul>
<li><p>解决方案：引入一种称为S型神经元的新的人工神经元来克服这个问题。S型神经元和感知器类似，但是被修改为权重和偏置的微小改动只引起输出的微小变化(这对于让神经元网络学习起来是很关键的)。</p>
</li>
<li><p><strong>S型神经元</strong>：有多个输入，这些输入可以取[0,1]中的任意值，而不仅仅是0和1。具有权重和偏置。但输出不是0或者1，而是<code>sigma(w·x+b)</code>,该函数为S型函数(逻辑函数)，定义为：</p>
</li>
</ul>
<p>  <img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120180707163.png" alt="image-20210120180707163"></p>
<p>  代入神经元参数为：</p>
<p>  <img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120180751519.png" alt="image-20210120180751519"></p>
<ul>
<li>S型神经元和感知器关系：当<code>z=w·x+b</code>取很大或者很小时其S型神经元的行为和感知器非常近似。只有<code>z</code>取中间值时与感知模型有较大的偏离。</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120181846815.png" alt="image-20210120181846815" style="zoom:67%;"></p>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120182011643.png" alt="image-20210120182011643" style="zoom:67%;"></p>
<ul>
<li>如果<code>sigma</code>函数是个阶跃函数，那么S型神经元将会成为一个感知器。之所以利用<code>sigma</code>函数是为了得到一个平滑的感知器。其<strong>平滑特性</strong>正是解决问题的关键因素，意味着权重和偏置的微小变化会从神经元产生一个微小的输出变化，利用微积分我们可以得到下式：</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120182810071.png" alt="image-20210120182810071" style="zoom:80%;"></p>
<ul>
<li><p>理解:<code>Δoutput</code>是一个反应Δwj和Δb的线性函数，使得选择权重和偏置的微小变化来达到输出的微小变化的运算变得容易。因此，当S型神经元有更多和感知器相同的本质的行为时，计算如何变化权重和偏置来使输出变化会更加容易。</p>
</li>
<li><p>为什么选用上面的<code>sigma</code>函数：对于<code>sigma</code>函数重要的是形状而不是精确形式，选用该函数的目的是简化数学计算，因为指数在求导时有些可爱的属性。</p>
</li>
<li>S型神经元输出的解释：并非只输出0 or 1，但我们可以设定一个约定来解决这个问题，例如约定任何至少为0.5的输出表示为“这是某个数字”</li>
</ul>
<h2 id="神经网络的架构"><a href="#神经网络的架构" class="headerlink" title="神经网络的架构"></a>神经网络的架构</h2><p>假设我们有这样的网络：</p>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120194421991.png" alt="image-20210120194421991" style="zoom:80%;"></p>
<ul>
<li><strong>输入层</strong>：网格中最左边的，其中的神经元为<strong>输入神经元</strong>。</li>
<li><strong>输出层</strong>：最右边的，有且只有一个<strong>输出神经元</strong>。</li>
<li><strong>隐藏层</strong>：中间包含既不输入也不输出的神经元的层。</li>
<li><strong>多层感知器</strong> or <strong>MLP</strong>：这种网络尽管是由S型神经元而不是感知器构成，但也称为多层感知器。</li>
</ul>
<p>设计输入输出层通常是比较直接的，隐藏层的设计则堪称一门艺术。特别是，通过一些简单的经验法则来总结隐藏层的设计流程是不可行的。相反，神经网络的研究人员已经为隐藏层开发了许多 设计最优法则。</p>
<ul>
<li><strong>前馈神经网络</strong>：以上一层的输出作为下一层的输入。这意味着网络中是没有回路 的——信息总是向前传播，从不反向反馈。</li>
<li>递归神经网络：反馈环路在其中是可行的，其设计思想是具有休眠前会在一段有限时间内保持激活状态的神经元。</li>
</ul>
<h2 id="一个简单的分类手写数字的网络"><a href="#一个简单的分类手写数字的网络" class="headerlink" title="一个简单的分类手写数字的网络"></a>一个简单的分类手写数字的网络</h2><p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210120194325646.png" alt="image-20210120194325646" style="zoom:80%;"></p>
<ul>
<li>网络的输入层包含给输入像素的值进行编码的神经元 ，含有784=28*28个神经元。输入像素是灰度级的，值为1.0表示黑色，值为0.0表示白色，中间数值表示逐渐暗淡的灰色。</li>
<li>网络的隐藏层用n来表示神经元的数量。</li>
<li>网络的输出层包含10个神经元。如果第一个神经元激活，即其输出近似为1，那么表明 网络认为数字是一个0。更确切地说，我们把神经元的输出赋予编号0到9，并计算哪个神经元有最高的激活值。</li>
<li>思考：为什么使用10个输出神经元而不是4个。2^4=16&gt;10完全可以表示10个数字。</li>
<li></li>
</ul>
<h2 id="使用梯度下降算法进行学习"><a href="#使用梯度下降算法进行学习" class="headerlink" title="使用梯度下降算法进行学习"></a>使用梯度下降算法进行学习</h2><ul>
<li><p>训练数据集：用来学习的数据集。</p>
</li>
<li><p><strong>MNIST数据集</strong>：其中包含有数以万计的连带着正确分类器的手写数字的扫描图像。</p>
<p>我们将使用符号x来表示一个训练输入。为了方便，把每个训练输入x看作一个28*28=784维的向量。我们用y=y(x)表示对应的期望输出，这里的y是一个10维向量。例如有一个“6”的训练图像x，那么y(x) = (0,0,0,0,0,0,1,0,0,0)<sup>T</sup> 则是网络的期望输出。T是转置操作，把一个行向量转化成列向量。</p>
</li>
</ul>
<ul>
<li><strong>代价 函数</strong>：我们希望有一个算法，能够让我们找到权重和偏置，以至于网络的输出y(x) 能够拟合所有的训练输入x。为了量化我们如何实现这个目标，我们定义了代价函数：</li>
</ul>
<p><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210121195359475.png" alt="image-20210121195359475" style="zoom:80%;"></p>
<ul>
<li><code>w</code>：所有的网络中权重的集合；<code>b</code>：所有的偏置；<code>n</code>：训练输入数据的个数；<code>a</code>：当输入为 x 时输出的向量；符号<code>||v||</code>指的是向量v的模。</li>
<li>我们把C称为<strong>二次代价函数</strong> or <strong>均方误差</strong> or <strong>MSE</strong>。</li>
<li><p>该函数是非负的，其值相当小，C(w,b) $\approx$ 0 。精确的说是在对于所有训练输入x，y(x)接近于输出a时。</p>
</li>
<li><p>我们需要使我们的学习算法找到合适的权重和偏置，使得C(w,b) $\approx$ 0，网络就能很好的工作。</p>
</li>
<li>我们采用<strong>梯度下降</strong>的算法来达到这个目的。</li>
<li>思考：为什么不适用正确分类的图片数量作为评量评估网络的能力？<br>被正确分类的图片数量所关于权重和偏置的函数并不是一个平滑函数，大多数情况下，对权重和偏置做出的微小变动完全不会影响被正确分类的图像数量。 </li>
<li>在该过程我们应该将精力集中在<strong>如何最小化代价函数</strong>，可以忽略MNIST，权重和偏置的等前面所提及的东西。</li>
</ul>
<ul>
<li><p><strong>最小化过程——梯度下降算法</strong><br>假设我们最小化函数C(v)，我们用v代替w和b以强调它可能是任意的函数。为了最小化C(v)我们想象C是一个只有两个变量$v_{1}$和$v_{2}$的函数：<br><img src="/2021/01/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-note/image-20210122144421179.png" alt="image-20210122144421179" style="zoom:80%;"><br>我们要找到C的全局最小值，对于上图我们一眼就能找到最小值。但通常函数C可能是一个复杂的多元函数，看一下就能找到最小值是不可能的。<br>一种方法是：<strong>微积分来解析最小值</strong>。但是变量过多的话就是噩梦，此时使用微积分显然是不可行的。<br>Luckily，<strong>有一种推导法暗示有一种算法能够得到很好的效果</strong>。</p>
<ul>
<li><p>将函数想象成一个山谷，我们想象有一个小球从山谷的斜坡滚落，日常经验告诉我们这个球最终会滚到谷底。</p>
</li>
<li><p>随机给球体一个起始位置，然后模拟球体滚落到谷底的运动。通过计算C的导数来简单模拟——这些导数能够告诉我们山谷中局部“形状”。</p>
</li>
<li><p>当我们在$v_{1}$和$v_{2}$方向分别将球体移动一个很小的量，微积分告诉我们C将会有如下变化:</p>
</li>
<li><script type="math/tex; mode=display">
\Delta C \approx \frac{\partial C}{\partial v_{1}}\Delta v_{1} + \frac{\partial C}{\partial v_{2}}\Delta v_{2}</script></li>
<li><p>寻找一中选择$\Delta v_{1}$和$\Delta v_{2}$使得$\Delta C$为负的方法。先定义$\Delta v$为$v$的变化向量，$\Delta v \equiv (\Delta v_1, \Delta v_2)^T$，T是转置符号。我们也定义C的梯度为偏导数的向量，$(\frac{\partial C}{\partial v_1},\frac{\partial C}{\partial v_2})^T$.我们用$\bigtriangledown C$表示梯度向量，即：<br>$\bigtriangledown C =(\frac{\partial C}{\partial v_1},\frac{\partial C}{\partial v_2})^T$</p>
</li>
<li><p>$\Delta C \approx \bigtriangledown C \cdot \Delta v$ 。$\bigtriangledown C$把$v$的变化关联为C的变化。——func1</p>
</li>
<li><p>我们选取$\Delta v = -\eta \bigtriangledown C$ ，这里的$\eta$是个很小的正数(<strong>学习速率</strong>)。——func2</p>
</li>
<li><p>结合上述两个式子：$\Delta C \approx - \eta \bigtriangledown C \cdot \bigtriangledown C = -\eta||\bigtriangledown C||^2$，由于$||\bigtriangledown C||^2 \geq 0$，这保证了$\Delta C \leq 0$，即，我们按照上面的选取规则$C$会一直减小，不会增大。因此，我们将上面的方程2用于定义球体在梯度下降算法中的“运动定律”。我们用上面的方程计算$\Delta v$，来移动球体的位置$v$：$v \rightarrow v’ = v-\eta \bigtriangledown C$ 。</p>
</li>
<li><p>不断更新规则来计算下一次移动，反复进行，将持续减小C直到获得一个全局最小值。</p>
</li>
<li><p><strong>总结：</strong>重复计算梯度$\bigtriangledown C$，然后沿着相反方向移动，沿着山谷“滚路”。为了是 梯度下降能够正确运行，我们需要选择足够小的学习速率$\eta$使得func2能够得到很好的近似。如果不这样我们会以$\Delta C &gt; 0$结束；同时，也不能使$\eta$太小，否则会使$\Delta v$变化极小，梯度下降算法就会运行的非常慢。</p>
</li>
<li><p><strong>扩展：</strong>函数$C$具有多个变量时</p>
</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
\Delta v=(\Delta v_1,...,\Delta v_m)</script><script type="math/tex; mode=display">
\Delta C \approx \bigtriangledown C \cdot \Delta v</script><script type="math/tex; mode=display">
\bigtriangledown C \equiv (\frac{\part C}{\part v_1},...,\frac{\part C}{\part v_m})^T</script><script type="math/tex; mode=display">
\Delta v = -\eta \bigtriangledown C</script><script type="math/tex; mode=display">
v \rightarrow v' = v-\eta \bigtriangledown C</script><ul>
<li><strong>使用梯度下降算法</strong><ul>
<li>“位置”变量用权重和偏置两个变量代替：$w_k,b_l$。</li>
<li>$w_k \rightarrow w_k’= w_k - \eta \frac {\partial C}{\partial w_k}$</li>
<li>$b_l \rightarrow b_l’= b_l - \eta \frac {\partial C}{\partial b_L}$</li>
<li>问题：$C= \frac{1} n \Sigma_x \bigtriangledown C_x$是普及每个训练样本代价$C_x \equiv \frac {||y(x)-a||^2} {2}$的平均值。在实践中，为了计算梯度$\bigtriangledown C$，我们需要为每个训练输入$x$单独的计算梯度值$\bigtriangledown C_x$，然后求平均值，这蒋辉使学习变得相当缓慢。</li>
<li>方案：<strong>随机梯度下降</strong><br>其思想：随机选取小量训练样本来计算$\bigtriangledown C_x$进而估算梯度$\bigtriangledown C$。,<br>随机选取小量的m个训练输入来工作，我们将其标记为$X_1,…,X_m$ ，称为<strong>小批量数据（mini-batcch)</strong>。假设足够大，我们期望$\bigtriangledown C_{X_j}$的平均值大致等于整个$\bigtriangledown C_x$的平均值，即：$\frac{\Sigma^m_{j=1} \bigtriangledown C_{X_j}}{m} \approx \frac{\Sigma_{x} \bigtriangledown C_{x}}{n} = \bigtriangledown C $<br>$\bigtriangledown C \approx \frac{1} {m} \sum ^m_{j=1} \bigtriangledown C_{X}$ </li>
<li>将其明确地和神经网路的学习联系起来，假设$w_k$和$b_l$表示神经网路中 权重和偏置，梯度下降通过随机地选取并训练输入的小批量数据来工作<br>$w_k \rightarrow w_k’ = w_k - \frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial w_k}$<br>$b_l \rightarrow b_l’ = b_l - \frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial b_l}$<br>其中两个求和符号实在当前小批量数据中的所有训练样本$X_j$上进行的。然后我们再挑选另一随机选定的小批量数据去训练，直到我们用完了所有的训练输入，这被称为<strong>完成了一个训练迭代期(epoch)</strong>,然后我们就会开始 另一个新的训练迭代期。</li>
</ul>
</li>
</ul>
<h2 id="实现我们的网络来分类数字"><a href="#实现我们的网络来分类数字" class="headerlink" title="实现我们的网络来分类数字"></a>实现我们的网络来分类数字</h2><h1 id="反向传播算法如何工作"><a href="#反向传播算法如何工作" class="headerlink" title="反向传播算法如何工作"></a>反向传播算法如何工作</h1><h1 id="改进神经网络的学习方法"><a href="#改进神经网络的学习方法" class="headerlink" title="改进神经网络的学习方法"></a>改进神经网络的学习方法</h1><h1 id="神经网络可以计算任何函数的可视化证明"><a href="#神经网络可以计算任何函数的可视化证明" class="headerlink" title="神经网络可以计算任何函数的可视化证明"></a>神经网络可以计算任何函数的可视化证明</h1><h1 id="深度神经网络为何很难训练"><a href="#深度神经网络为何很难训练" class="headerlink" title="深度神经网络为何很难训练"></a>深度神经网络为何很难训练</h1><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1>]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2021/01/19/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><em>markdown的使用指南及问题解决</em></p>
<a id="more"></a>
<h1 id="markdown-代码"><a href="#markdown-代码" class="headerlink" title="markdown 代码"></a>markdown 代码</h1><ul>
<li><strong>代码</strong> 使用<strong>反引号`</strong>效果如下：</li>
</ul>
<p><code>hello world</code></p>
<ul>
<li><strong>代码区块</strong>使用<strong>4个空格 or 制表符Tab</strong>，效果如下：</li>
</ul>
<ul>
<li><strong>代码区块</strong>还使用<strong>```</strong>包裹一段代码，实例如下：</li>
</ul>
<p>code:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">​<span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">$(document).ready(function () &#123;</span></span><br><span class="line"><span class="string">    alert(&#x27;RUNOOB&#x27;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">​`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="markdown-段落"><a href="#markdown-段落" class="headerlink" title="markdown 段落"></a>markdown 段落</h1><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>在文本的两端加上两条波浪线即可<strong>~~</strong>,实例如下：</p>
<p><code>~~hello,world~~</code></p>
<p><del>hello,world</del></p>
<h2 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h2><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|左对齐|居中|右对齐|</span><br><span class="line">|:-----|:-:|-----:|</span><br><span class="line">|xxxxxx|xxx|xxxxxx|</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">H&lt;sub&gt;2&lt;&#x2F;sub&gt;O  CO&lt;sub&gt;2&lt;&#x2F;sub&gt;</span><br><span class="line">爆米&lt;sup&gt;TM&lt;&#x2F;sup&gt;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p>H<sub>2</sub>O  CO<sub>2</sub></p>
<p>爆米<sup>TM</sup></p>
<h1 id="markdown-特殊字符"><a href="#markdown-特殊字符" class="headerlink" title="markdown 特殊字符"></a>markdown 特殊字符</h1><h2 id="行内添加数学公式"><a href="#行内添加数学公式" class="headerlink" title="行内添加数学公式"></a>行内添加数学公式</h2><p>在文本行内添加数学公式需要开启<strong>内联公式</strong>。</p>
<p><code>文件-&gt;偏好设置-&gt;Markdown</code>中将内联公式勾选。</p>
<script type="math/tex; mode=display">\approx$$              $\approx$





## 插入数学公式

键入$$$$ 后 `Enter` 即可。</script><p>$$</p>
<h2 id="附录：Latex数学符号常用表"><a href="#附录：Latex数学符号常用表" class="headerlink" title="附录：Latex数学符号常用表"></a>附录：Latex数学符号常用表</h2><ul>
<li>上标 <br> <script type="math/tex">a^2</script>    -&gt;   $a^2$<br> <script type="math/tex">a^{222}</script>   -&gt;   $a^{222}$  </li>
<li>下标 <br> <script type="math/tex">A_{b_{c}}</script>   -&gt;   $A_{b_{C}}$ </li>
<li>前角标<br> <script type="math/tex">{^1_2}A{^3_4}</script>   -&gt;   ${^1_2}A{^3_4}$</li>
</ul>
<p><img src="/2021/01/19/markdown%E8%AF%AD%E6%B3%95/20190703164359871.png" alt="img"></p>
<p><img src="/2021/01/19/markdown%E8%AF%AD%E6%B3%95/20190703164424334.png" alt="6"></p>
<p><img src="/2021/01/19/markdown%E8%AF%AD%E6%B3%95/20190703164439850.png" alt="7-9"></p>
<p><img src="/2021/01/19/markdown%E8%AF%AD%E6%B3%95/20190703164500390.png" alt="10-13">    </p>
<h1 id="markdown-特殊操作"><a href="#markdown-特殊操作" class="headerlink" title="markdown 特殊操作"></a>markdown 特殊操作</h1><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p><code>&lt;br/</code>可以实现换行但与Enter效果不同</p>
]]></content>
  </entry>
  <entry>
    <title>hexo-next blog搭建及使用</title>
    <url>/2021/01/19/hexo-next-blog%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>hexo-next blog搭建过程及使用过程中的问题及解决方案</p>
<a id="more"></a>



<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="blog中插入图片"><a href="#blog中插入图片" class="headerlink" title="blog中插入图片"></a>blog中插入图片</h2><p>在配置文件中打开<strong>文章资源文件夹</strong></p>
<p><code>post_asset_folder: true</code></p>
<p>安装插件</p>
<p><code> npm install hexo-asset-image --save</code></p>
<p>打开文件<code>/node_modules/hexo-asset-image/index.js</code>将代码替换为下列代码</p>
<p>（在此感谢Ericam_ 大神：<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/xjm850552586">https://blog.csdn.net/xjm850552586</a>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">var cheerio = require(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line"><span class="keyword">function</span> getPosition(str, m, i) &#123;</span><br><span class="line">  <span class="built_in">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version = String(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(data)&#123;</span><br><span class="line">  var config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        var link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)</span><br><span class="line">       var beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, 1) + 1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       var beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, 3) + 1;</span><br><span class="line">    // In hexo 3.1.1, the permalink of <span class="string">&quot;about&quot;</span> page is like <span class="string">&quot;.../about/index.html&quot;</span>.</span><br><span class="line">    var endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + 1;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(this).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            // For windows style path, we replace <span class="string">&#x27;\&#x27;</span> to <span class="string">&#x27;/&#x27;</span>.</span><br><span class="line">            var src = $(this).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!/http[s]*.*|\/\/.*/.<span class="built_in">test</span>(src) &amp;&amp;</span><br><span class="line">               !/^\s*\//.<span class="built_in">test</span>(src)) &#123;</span><br><span class="line">              // For <span class="string">&quot;about&quot;</span> page, the first part of <span class="string">&quot;src&quot;</span> can<span class="string">&#x27;t be removed.</span></span><br><span class="line"><span class="string">              // In addition, to support multi-level local directory.</span></span><br><span class="line"><span class="string">              var linkArray = link.split(&#x27;</span>/<span class="string">&#x27;).filter(function(elem)&#123;</span></span><br><span class="line"><span class="string">                return elem != &#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">              &#125;);</span></span><br><span class="line"><span class="string">              var srcArray = src.split(&#x27;</span>/<span class="string">&#x27;).filter(function(elem)&#123;</span></span><br><span class="line"><span class="string">                return elem != &#x27;</span><span class="string">&#x27; &amp;&amp; elem != &#x27;</span>.<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">              &#125;);</span></span><br><span class="line"><span class="string">              if(srcArray.length &gt; 1)</span></span><br><span class="line"><span class="string">                srcArray.shift();</span></span><br><span class="line"><span class="string">              src = srcArray.join(&#x27;</span>/<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">              $(this).attr(&#x27;</span>src<span class="string">&#x27;, config.root + link + src);</span></span><br><span class="line"><span class="string">              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;else&#123;</span></span><br><span class="line"><span class="string">            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span></span><br><span class="line"><span class="string">            console.info&amp;&amp;console.info($(this));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">      data[key] = $.html();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>


<p>Typora对于插入图片的支持做得非常好，在<code>文件-&gt;偏好设置-&gt;图像</code>中选择<code>复制到指定的路径</code> <code>./$&#123;filename&#125;</code> </p>
<p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p>
<p>如复制网络路径的图片<code>https://...../image.jpg</code>粘贴到Typora中叫<code>文章名</code>的文章后，图片会自动变为<code>![](文章名/image.jpg)</code>。</p>
<p>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的<code>文件名/</code>。不慌，也很简单。</p>
<p>在Typora编辑器中，使用<code>&lt;C-f&gt;</code>快捷键，将所有的<code>文章名/</code>替换为空即可删除。</p>
<p><img src="/2021/01/19/hexo-next-blog%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/among-us-3840x2160-artwork-4k-23114-1611067673187.jpg" alt="among-us-3840x2160-artwork-4k-23114"></p>
]]></content>
  </entry>
  <entry>
    <title>python学习记录</title>
    <url>/2021/01/21/python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><em>记录python的学习过程。</em></p>
<a id="more"></a>
<h1 id="Python3-环境搭建"><a href="#Python3-环境搭建" class="headerlink" title="Python3 环境搭建"></a>Python3 环境搭建</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><h2 id="运行python"><a href="#运行python" class="headerlink" title="运行python"></a>运行python</h2><h1 id="Python基本语法"><a href="#Python基本语法" class="headerlink" title="Python基本语法"></a>Python基本语法</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>字母或下划线(_)开头</li>
<li>字母下划线数字组成</li>
<li>对大小写敏感</li>
<li>在PYthon3中可以用中文作为变量名，非ASCII码也是允许的</li>
</ul>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class="line">[<span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, <span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>单行注释以<strong>#</strong>开头</li>
</ul>
<ul>
<li>多行注释可以使用多个<strong>#</strong>号，或者用<strong>```</strong>和<strong>“””</strong>包裹</li>
</ul>
<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python最具特色的就是<strong>缩进来表示代码块，而不是使用大括号</strong><code>&#123;&#125;</code></p>
<p>所进的空格数是可变的，但是<strong>同一个代码块的语句必须包含相同的空格数</strong></p>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>python通常是一行写完一条语句，但是如果语句过长我们可以<strong>使用反斜杠()来实现多行语句</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>
<p><strong>在[],{},()中的多行语句不需要使用</strong></p>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p><strong>记住：</strong>空行也是程序代码的一部分。</p>
<h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><p>执行<code>input()</code>函数后等待用户键入，按下Enter后结束键入</p>
<h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>python可以在一行中使用多条语句，语句之间用<code>分号;</code>分割</p>
<h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像<code>if``while``def``class</code>这样的复合语句，首行以关键字开始，以：号结束，改行之后的一行或者多行构成代码组。我们将首行及后面的代码组称为一个子句(clasuse)</p>
<h2 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h2><p><code>print</code>默认输出是换行的，如果实现不换行的输出需要在变量末尾加上<code>end=&quot;&quot;</code></p>
<h2 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h2><p>用<code>import</code>或者<code>from..import</code>来导入相应的模块</p>
<p>将整个模块(somemodule)导入：<code>import somemodule</code></p>
<p>从某个模块中导入某个函数：<code>from somemodule import somefunction</code></p>
<p>从某个模块中导入多个函数：<code>from somemodule import firstfunc, secondfunc, thirdfunc</code></p>
<p>将某个模块中的全部函数导入：<code>from somemoudle import *</code></p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>python可以使用<code>-h</code>参数查看各参数帮助信息</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><strong>python中的变量不需要声明，每个变量在使用前都必须赋值，变量被赋值后该变量才会被创建。</strong></p>
<p><strong>在python中，变量就是变量，没有类型，我们所说的“类型”是变量所指的内存中对象的类型。</strong></p>
<p><code>等号 =</code> :用来给变量赋值，其左边是一个变量名，右边是存储在变量中的值。</p>
<h2 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h2><p>Python允许同时为多个变量赋值：</p>
<ul>
<li><code>a = b = c = 1</code>，创建一个整型对象，值为1，三个变量被赋予相同的数值。</li>
<li><code>a, b, c = 1, 2, &quot;hello&quot;</code>，两个整型对象1和2分配给a和b，字符串对象“hello”分配给变量c。</li>
</ul>
<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<p><strong>不可变数据</strong>：Number，String，Tuple；</p>
<p><strong>可变数据</strong>：List，Dictionary，Set。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java与Android移动应用开发</title>
    <url>/2021/03/03/Java%E4%B8%8EAndroid%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p><em>java学习之路——勇往直前吧！</em></p>
<a id="more"></a>
<h1 id="Java开发基础"><a href="#Java开发基础" class="headerlink" title="Java开发基础"></a>Java开发基础</h1><h2 id="语句和语句块"><a href="#语句和语句块" class="headerlink" title="语句和语句块"></a>语句和语句块</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> firstdemo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;HelloJava&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>package</strong>语句：代码定义在哪个包中，结尾要有<strong>;</strong> </li>
<li><strong>import</strong>语句：引用其他包中的资源</li>
<li><strong>public</strong>和<strong>class</strong>关键字：定义一个类，使用 <strong>{}</strong> 定义类的主体部分，称为代码块</li>
<li><strong>main()</strong>：类中可能会包含很多成员，main()方法是程序执行的入口，其主体同样用 <strong>{}</strong> 定义</li>
<li><strong>System.out.println()方法</strong>：输出一些内容</li>
</ul>
<h2 id="注释内容"><a href="#注释内容" class="headerlink" title="注释内容"></a>注释内容</h2><p>Java中，有四种注释方法：</p>
<p><strong>行注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注释内容</span></span><br><span class="line">System.out.println(<span class="string">&quot;HelloJava&quot;</span>);  <span class="comment">//注释内容</span></span><br></pre></td></tr></table></figure>
<p><strong>块注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>块注释中使用@</strong></p>
<p>用@符号表示的指令，可以通过javadoc命令创建HTML文档。</p>
<p><strong>文档注释</strong></p>
<p><code>/**      */</code></p>
<h2 id="保留字标识符"><a href="#保留字标识符" class="headerlink" title="保留字标识符"></a>保留字标识符</h2><p><strong>标识符规范</strong>：可以使用字母、下划线、$符号和数字等，但是第一个字符不能为数字。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><strong>最终变量（常量）</strong>：在其类型前使用<strong>final</strong>关键字。</p>
<p><strong>定义规范</strong>：同时定义多个相同类型变量时可以使用<code>,</code>分隔，并可以分别赋值。</p>
<p><strong>不同类型的数据之间进行运算</strong>：</p>
<ul>
<li>基本类型之间转化：除boolean自动进行转换：<code>byte,short,char – int–long–float–double</code>。即表述范围小的可以自动转化为表述范围大的。</li>
<li>基本类型和String：基本类型与String之间的运算，会转换成String类型。</li>
</ul>
<p><strong>byte类型数据是有符号的</strong>，当数据为负数时，其二进制实际上是其绝对值的补码形式，。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> x = <span class="number">0b00000010</span>;</span><br><span class="line">System.out.println(~x);  </span><br><span class="line"><span class="comment">//-3, 0b11111101</span></span><br><span class="line"><span class="comment">//整数3的8位二进制形式为00000011</span></span><br><span class="line"><span class="comment">//补码的计算是按位取反后加1</span></span><br><span class="line"><span class="comment">//3的补码为11111100+1=11111101</span></span><br><span class="line"><span class="comment">//故0b11111101表示-3</span></span><br></pre></td></tr></table></figure>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><p>默认为十进制，但也可以使用其他进制。</p>
<ul>
<li>0开头的定义为八进制，<code>020</code>表示十进制数16.</li>
<li>0x开头定义为十六进制，<code>0xf</code>表示十进制数15。</li>
<li>0b开头定义为二进制，<code>0b0101</code>表示十进制数5。</li>
</ul>
<h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><ul>
<li>可以使用：+、-、*、/和%运算符。</li>
<li><p>整数运算的结果仍为整数，<strong>如果运算数的类型不一样，则统一转化为取值范围较大的类型，然后进行计算</strong>。</p>
</li>
<li><p>整数的除法和取余运算如果右运算数为0会产生错误。</p>
</li>
</ul>
<h4 id="增量与减量运算"><a href="#增量与减量运算" class="headerlink" title="增量与减量运算"></a>增量与减量运算</h4><p>对于前增量和后增量操作，如果只需要使用变量运算后的值则他们是一样的；但是在使用运算表达式的值时，则有区别。</p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h5 id="逻辑位运算"><a href="#逻辑位运算" class="headerlink" title="逻辑位运算"></a>逻辑位运算</h5><p>对操作数的二进制位进行逻辑运算。</p>
<ul>
<li><p><strong>&amp;</strong>：与运算，当两个二进制位数据都为1时返回1，否则为0</p>
</li>
<li><p><strong>|</strong>：或运算，当两个二进制位数据都为0时返回0，否则为1</p>
</li>
<li><strong>~</strong>：取反运算，二进制数据为1时返回0，为0时返回1</li>
<li><strong>^</strong>：异或运算，当两个二进制位数据相同时返回0，不同时返回1</li>
</ul>
<p>在实际开发工作中，逻辑位运算经常进行一些标识数据的比较工作。</p>
<h5 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h5><ul>
<li><strong>&lt;&lt;</strong>：位左移运算，二进制位会向左移动，低位补0。<strong>当整数x进行左移n位运算时，就是在执行：x * (2 ^ n)</strong>。如果左移运算超出类型支持的位数，超出部分会丢失，即数据溢出。</li>
<li><strong>&gt;&gt;</strong>：位右移运算，二进制位会向右移动，<strong>符号位不动，右移空出的高位要补上与符号位相同的数据，执行x / (2 ^ n)</strong>。</li>
<li><strong>&gt;&gt;&gt;</strong>：无符号右移运算，使用时不考虑符号位，整体右移且高位补0。</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数指可以处理小数部分的数据类型。</p>
<p>支持运算：算术运算和增量减量，但不能进行位运算。</p>
<ul>
<li><strong>double双精度浮点数</strong>：64位。含有小数部分的数据默认类型为double。如果需要明确指出数据是double类型，可以使用d或D后缀。</li>
<li><strong>float单精度浮点数</strong>：32位。使用f或F后缀。</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>把一个取值范围小的类型转化为取值范围大的类型。</p>
<p>不同数据类型进行运算时会进行隐形转换。</p>
<h3 id="非隐式转换"><a href="#非隐式转换" class="headerlink" title="非隐式转换"></a>非隐式转换</h3><p>把一个取值范围大的类型转化为取值范围小的类型。</p>
<p>这是不能被正确执行的，如果确实需要这种转换操作，就必须进行强制转换。在需要转换的数据前使用<code>()</code>指定目标类型。当数据超出目标类型的取值范围，会进行截断操作，数据内容会发生改变。浮点数转化为整数时会丢失小数部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> y = (<span class="keyword">int</span>) x;</span><br></pre></td></tr></table></figure>
<p> char类型</p>
<p>用于处理Unicode字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(ch);  <span class="comment">//A</span></span><br><span class="line">System.out.println( (<span class="keyword">int</span>) ch ); <span class="comment">//65 A的ASCII码</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>) <span class="number">65</span>);  <span class="comment">//A</span></span><br></pre></td></tr></table></figure>
<p>Java代码文件完全支持Unicode字符，也就是说可以使用中文来作为变量名。</p>
<p><strong>转义字符</strong></p>
<ul>
<li><code>\n</code></li>
<li><code>\r</code></li>
<li><code>\f</code></li>
<li><code>\b</code></li>
<li><code>\t</code></li>
<li><code>\\</code></li>
<li><code>\&quot;</code></li>
<li><code>\&#39;</code></li>
<li><code>\uxxx</code></li>
</ul>
<h2 id="bioolean类型"><a href="#bioolean类型" class="headerlink" title="bioolean类型"></a>bioolean类型</h2><p>布尔类型或逻辑型</p>
<ul>
<li>&amp;&amp;</li>
<li>||</li>
<li>!</li>
</ul>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举是一种自定义的数据类型，其中定义了可用的数据（枚举值）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ESex</span> </span>&#123;unknow, male, female&#125;;</span><br><span class="line"><span class="comment">//enum关键字后指定枚举类型的名称。枚举成员定义在&#123;&#125;中，用逗号分隔</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args)</span> </span>&#123;</span><br><span class="line">    ESex sex = ESex.male;</span><br><span class="line">    System.out.println(sex); <span class="comment">//male</span></span><br><span class="line">    System.out.println(sex.ordinal());  <span class="comment">//1</span></span><br><span class="line">    System.out.println(ESex.values()[<span class="number">2</span>]); <span class="comment">//female</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型的本质：每个成员都会有一个整数索引值，第一个成员的索引值位0，以此类推。当枚举类型和整数类型进行转换时，实际上就是在成员索引值和成员名称之间进行转换。<br>枚举成员需要大写，且不能再调用类中直接使用被调用类中的枚举类型。</p>
<h2 id="代码的组织和应用程序的基本结构"><a href="#代码的组织和应用程序的基本结构" class="headerlink" title="代码的组织和应用程序的基本结构"></a>代码的组织和应用程序的基本结构</h2><p>每一个发布项目都应该有一个唯一的包（package）名。</p>
<p>习惯的方法：反向域名+应用名</p>
<p>由一个或多个类组成，其中必须有一个定义了main()方法。</p>
<p>程序的源代码结构<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package</span><br><span class="line">import</span><br><span class="line">---------------</span><br><span class="line">class 类1&#123;</span><br><span class="line">    ----------</span><br><span class="line">    方法</span><br><span class="line">    ----------</span><br><span class="line">    变量</span><br><span class="line">    ----------</span><br><span class="line">&#125;</span><br><span class="line">class 类2&#123;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br><span class="line">..............</span><br></pre></td></tr></table></figure></p>
<ul>
<li>每个源文件中只能有一个类或接口是公共的</li>
<li>编译后每个类产生一个.class文件</li>
<li>包是每个java系统用来组织类的组织</li>
<li>编程只能在方法中进行</li>
</ul>
<h1 id="面向对象编程-OPP"><a href="#面向对象编程-OPP" class="headerlink" title="面向对象编程 OPP"></a>面向对象编程 OPP</h1><p>面向对象编程就是将一系列数据及其操作进行封装，让数据更直观、代码维护更高效。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类（class）是一种更加复杂的数据类型，它主要包括两种成员<strong>字段(field)</strong> 和 <strong>方法(method)</strong>。字段用来存储数据，方法则定义数据的一些列操作。</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><h4 id="类的定义语法"><a href="#类的定义语法" class="headerlink" title="类的定义语法"></a>类的定义语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> firstdemo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CAuto</span> </span>&#123;</span><br><span class="line"><span class="comment">//[类的修饰符] class 类名</span></span><br><span class="line">  <span class="comment">//[extends 父类名] 仅可以继承一个父类</span></span><br><span class="line">  <span class="comment">//[implments 接口名] 可以有多个接口</span></span><br><span class="line">    <span class="keyword">public</span> String model = <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> doors = <span class="number">4</span>;</span><br><span class="line">  <span class="comment">//成员变量定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveTO</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        String s = String.format(<span class="string">&quot;%s 移动到 (%d, %d)&quot;</span>, model,x,y);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>model字段，表示车的型号，定义为String类型，默认为空字符串。</li>
<li>doors字段，表示车门的数量，定义为int类型，默认为4。</li>
<li>moveTO()方法，用于显示车的移动信息。</li>
<li>String.format()方法，将各种类型的数据组合为字符串类型。</li>
<li>类修饰符：<ul>
<li>public:允许其他类访问，一个源文件仅可以有一个public类。</li>
<li>abstract：没有实例的抽象类。</li>
<li>final：不能再被拓展，不能有子类；易于安全的实现。</li>
</ul>
</li>
</ul>
<h4 id="类的成员变量的声明"><a href="#类的成员变量的声明" class="headerlink" title="类的成员变量的声明"></a>类的成员变量的声明</h4><p><code>[public|protected|private] [static|] [final] [transient] [volatile]</code></p>
<p><strong>static</strong>：类成员变量，对所有的实例一致<br><strong>final</strong>：数值不变常量，定义同时需要进行初始化<br><strong>transient</strong>：暂时性变量，用于对象存档<br><strong>volatile</strong>：易变变量，用于并发线程共享</p>
<h4 id="类的方法声明"><a href="#类的方法声明" class="headerlink" title="类的方法声明"></a>类的方法声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">public</span>|<span class="keyword">protected</span>|<span class="keyword">private</span>] [<span class="keyword">static</span>|] [<span class="keyword">final</span>] [<span class="keyword">abstract</span>] [<span class="keyword">native</span>] [<span class="keyword">synchronized</span>] 返回类型 方法名 (参数列表)</span><br><span class="line">[ <span class="keyword">throws</span> 例外名]</span><br><span class="line">&#123;</span><br><span class="line">    方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>static:静态方法，在方法体中只能使用静态方法和静态变量</li>
</ul>
<h3 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h3><ul>
<li><p>定义此类型的“变量”：<code>CAuto auto</code><br>auto称为类的一个<strong>实例（instance）或者CAuto类型的对象</strong>，简称为auto对象。此时auto对象暂时还不能使用，因为它还没有实例化，其值默认为null。</p>
</li>
<li><p>对象的实例化：<code>CAuto auto = new CAuto();</code><br>实例化一个对象需要使用<strong>new</strong>关键字。</p>
</li>
<li><p>应用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">auto.model = <span class="string">&quot;x9&quot;</span>;</span><br><span class="line">auto.moveTo(<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>代码中，<strong>圆点运算符（.）</strong>用来调用对象的字段和方法。</p>
</li>
</ul>
<h3 id="构造函数和对象释放"><a href="#构造函数和对象释放" class="headerlink" title="构造函数和对象释放"></a>构造函数和对象释放</h3><p><code>CAuto auto = new CAuto();</code><br>代码中<code>CAuto()</code>是方法，为CAuto类的构造函数。类在创建时会包含一个空的构造函数。</p>
<p>构造函数看上去和方法差不多，但是他的名称与类相同，而且不需要定义返回值类型。一个类可以定义多个构造函数，<strong>只要它们的参数设置能够有效区分就可以</strong>。</p>
<p><strong>构造函数链</strong>：减少重复代码，提高维护效率<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CAuto</span><span class="params">(String m, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    model = m;</span><br><span class="line">    doors = d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CAuto</span><span class="params">(String m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(m, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CAuto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>this</strong>：此关键字指当前实例。当运行构造函数2时会调用当前实例的构造函数1，同理运行构造函数3时会调用构造函数2进而调用构造函数1。<br><strong>super</strong>：对父类构造方法的调用</p>
<p><strong>对象释放</strong>：Java运行环境可以自动回收不再使用的对象，大多数情况下不需要开发者编写代码进行处理。但是当对象中使用了一些外部资源时，就应该保证这些资源能够正确地关闭。</p>
<h3 id="getter-和setter-方法"><a href="#getter-和setter-方法" class="headerlink" title="getter()和setter()方法"></a>getter()和setter()方法</h3><p>用这两种方法控制字段数据的读取和设置操作。对私有成员变量访问和修改的方法。</p>
<h3 id="静态成员与静态初始化"><a href="#静态成员与静态初始化" class="headerlink" title="静态成员与静态初始化"></a>静态成员与静态初始化</h3><p>类中创建的字段和方法都必须使用类的实例来访问，称为类的实例成员。不同于类的实例成员，静态成员可以使用类的名称直接访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> example = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果需要对静态成员初始化，可以再类中使用<strong>static</strong>语句定义一个结构体来完成，<strong>结构体中的代码会在第一次调用静态成员时执行一次</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="comment">//静态初始化结构</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态初始化&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;修饰符&gt; &lt;返回值类型&gt; &lt;方法名&gt;(参数列表) &#123;</span><br><span class="line">  &lt;方法体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修饰符：确定方法的访问形式与访问级别</p>
<h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>方法中需要使用零个或多个相同类型的参数，可以通过可变长(variable-length)参数简化参数定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(String... names)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(String s : names) &#123;</span><br><span class="line">    System.out.println(s + <span class="string">&quot;加入&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在String后面使用<strong>…运算符</strong>，调用join()方法时就可以使用零个或者多个String类型的参数了。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载：多个方法具有相同的名称，但因为不同的参数类型或者个数可以明显区分，构造函数就是典型的重载函数。</p>
<p>静态多态性。</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类名 <span class="keyword">extends</span> 超类名 </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类：继承后得到的类<br>超类：被继承的类，又称为基类或者父类<br>继承范围：无参数的构造函数和非私有成员<br>final关键字：在定义类时使用该关键字则该类不可被继承<br>继承唯一：子类只能有一个直接超类</p>
<h3 id="java-lang-Object类"><a href="#java-lang-Object类" class="headerlink" title="java.lang.Object类"></a>java.lang.Object类</h3><ul>
<li><p>Object类位于包java.lang包中，java.lang包包含着Java最基础和核心的类，编译时会自动导入。</p>
</li>
<li><p>Object类是Java类的鼻祖，每个类都是用Object类作为超类。因此我们可以使用一些Object类中的非私有成员在所有类中。</p>
</li>
</ul>
<h3 id="拓展和重写"><a href="#拓展和重写" class="headerlink" title="拓展和重写"></a>拓展和重写</h3><p>子类如果单纯地继承超类那么它的意义不大，事实上，子类可以拓展超类的功能，或者对超类的功能进行重写。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>如果在子类中没有定义构造函数，默认会继承超类中的无参数构造函数；<br>如果子类中定义了一个构造函数，就不能直接使用超类的构造函数创建对象了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超类</span></span><br><span class="line"><span class="keyword">package</span> src;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String inname)</span></span>&#123;</span><br><span class="line">        name = inname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;unknow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">package</span> src;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类中没有定义构造函数会默认继承超类的无参数构造函数，name=unknow</span></span><br></pre></td></tr></table></figure>
<p>超类中创建的构造函数并不是没有用武之地了，可以在子类中加个“外壳”用来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超类</span></span><br><span class="line"><span class="keyword">package</span> src;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String inname)</span></span>&#123;</span><br><span class="line">        name = inname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;unknow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">package</span> src;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>super关键字</strong>：调用超类的构造函数<br>使用this和super关键字可以合理地重用当前类或者超类中的构造函数。<br>只能放在方法体中的第一个语句。</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>子类如果需要重新实现超类中的成员，可以直接定义。还可以使用super关键字访问超类中的成员。</p>
<p>运行时多态性。</p>
<h3 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h3><ul>
<li>private：私有，只能在其定义的类中使用</li>
<li>protected：受保护，在其定义的类和子类中访问</li>
<li>public：公共，可以供类外部代码调用</li>
<li>default：默认访问级别，可在类外部调用，只能在其定义的包中使用。</li>
</ul>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>用于判断一个对象是否为某个类的实例。<br>A为B的一个实例；B为C的子类。<br>| 实例    | 类 | 返回值 |<br>| :——-: | :—-: | :——-: |<br>| A instanceof | B | true |<br>| A instanceof | C| true |<br>| A instanceof | Object | true |</p>
<h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><ul>
<li>定义方法时使用abstract关键字，方法就定义为抽象方法。</li>
<li>抽象方法并不需要方法体，它必须由类的子类来实现。</li>
<li>当一个类中包含抽象方法时，这个类应定义为抽象类。</li>
<li>抽象类像是标准的制定者，它可以定义一系列抽象方法，然后让其子类去具体实现，从而创建具有相同成员但实现各有不同的类型。</li>
<li>可以有构造方法</li>
</ul>
<h2 id="数据类型处理"><a href="#数据类型处理" class="headerlink" title="数据类型处理"></a>数据类型处理</h2><h3 id="基本数据类型和包装类"><a href="#基本数据类型和包装类" class="headerlink" title="基本数据类型和包装类"></a>基本数据类型和包装类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">基本数据类型</th>
<th style="text-align:center">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">java.lang.Byte</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">java.lang.Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">java.lang.Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">java.lang.Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">java.lang.Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">java.lang.Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">java.lang.Double</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">java.lang.Char</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">java.lang.Boolean</td>
</tr>
</tbody>
</table>
</div>
<p>当基本数据类型需要面向对象操作时可以将其转化为对象来使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer objx = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">    System.out.println(objx.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Integer类的构造函数代入一个整数，从而创建一个值为10的Integer对象。然后，通过toString()方法显示其内容。、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer objx = <span class="number">10</span>;</span><br><span class="line">System.out.println(objx.toString());</span><br></pre></td></tr></table></figure>
<p>这里，直接将整数赋值给Integer类型的objx，编译器会自动完成转换工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer objx = <span class="number">10</span>;</span><br><span class="line">    System.out.println(objx.intValue());     <span class="comment">//10</span></span><br><span class="line">    System.out.println(objx.floatValue());;  <span class="comment">//10.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>intValue()和floatValue()方法可以将objx对象中的数据转化为整数和浮点数。</p>
<h3 id="数据的传递"><a href="#数据的传递" class="headerlink" title="数据的传递"></a>数据的传递</h3><p>基本数据类型称为值类型，而所有的类称为引用类型。</p>
<ul>
<li>值类型的参数在传递过程中会产生一个副本，其本身不会改变。</li>
<li>引用类型在传递时会传递其对象位于内存中的位置，作为参数时自身可能会发生改变。</li>
<li>String类型，引用类型中的异类。其用于处理不可变字符串类型，即String对象的内容一旦确定就不能改变，对于字符串内容的任何操作，都会生成一个新的字符串对象。</li>
</ul>
<h3 id="类型的动态处理"><a href="#类型的动态处理" class="headerlink" title="类型的动态处理"></a>类型的动态处理</h3><p>Object类的常用成员：</p>
<ul>
<li><strong>eauals()</strong>：与参数指定的对象进行比较，当两个对象是同一引用时返回true。</li>
<li><strong>toString()</strong>：返回对象的文本描述。</li>
<li><strong>getClass()</strong>：返回一个Class类型的对象，即对象类型的描述对象。</li>
</ul>
<h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><ul>
<li>class</li>
<li>接口</li>
<li>数组</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是一种特殊对象，其长度可以用数组名.length获得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组声明：</span></span><br><span class="line"><span class="keyword">int</span>[] d;</span><br><span class="line">String[] n;</span><br><span class="line"><span class="keyword">char</span> c[];</span><br><span class="line"><span class="comment">//[]可以放在这两个位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">int</span> d[];</span><br><span class="line">d = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//new的作用内存分配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">int</span>[] d = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象初始化</span></span><br><span class="line">student []st = <span class="keyword">new</span> student[<span class="number">4</span>];</span><br><span class="line">st[<span class="number">0</span>] = <span class="keyword">new</span> student();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组可以是维数不同的</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">int</span>[][] d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//不同的</span></span><br><span class="line"><span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line"><span class="keyword">int</span>[<span class="number">0</span>][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span>[<span class="number">1</span>][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="创建接口类型"><a href="#创建接口类型" class="headerlink" title="创建接口类型"></a>创建接口类型</h2><p>接口中的方法默认是public和abstract类型的，必须由类具体实现。且必须实现为公共的<br>public static final常数默认修饰<br>public abstract方法默认修饰</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>实现接口的类中，需要实现接口中定义的方法或字段且为public<br>必须实现全部方法，如果不需要也要定义成空的方法体</p>
<h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>可以被继承，且可以被多重继承。</p>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始条件; 执行条件; 循环控制变量循环后变化)&#123;</span><br><span class="line">    代码块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><h1 id="包-Java-API"><a href="#包-Java-API" class="headerlink" title="包 Java API"></a>包 Java API</h1><p>包是用途相近功能不同的类和接口的松散集合。<br>类库由若干包组成。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Java.lang</td>
<td style="text-align:center">java 核心语言库。程序运行时会自动引用该类</td>
</tr>
<tr>
<td style="text-align:center">java.util</td>
<td style="text-align:center">实用程序包，包括了一些低级的实用工具</td>
</tr>
<tr>
<td style="text-align:center">java.awt</td>
<td style="text-align:center">界面开发，开发界面不是特别美观和底层关系大</td>
</tr>
<tr>
<td style="text-align:center">java.swing</td>
<td style="text-align:center">界面开发，相对美观</td>
</tr>
<tr>
<td style="text-align:center">java.io</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">java.sql</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">java.net</td>
</tr>
</tbody>
</table>
</div>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯</title>
    <url>/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/</url>
    <content><![CDATA[<p><em>2021年蓝桥杯准备笔记。</em><br><a id="more"></a></p>
<h1 id="last"><a href="#last" class="headerlink" title="last"></a>last</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>末尾以<code>\0</code>结束的字符型数组称为字符串。值得强调的是只有以<code>\0</code>结束的才算字符串，否则只能算字符数组。</p>
<p><strong>strcpy()</strong>函数：复制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;hellowlrld&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(name, str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name;</span><br></pre></td></tr></table></figure>
<p><strong>strcat</strong>函数：拼接</p>
<p><strong>strcmp()</strong>函数：比较，如果两个字符串完全相同返回0.从第一个字符开始逐字符比较ASCII码，返回第一个不相同字符ASCII码差值。</p>
<p><strong>strlen()</strong>函数；返回字符串长度</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>栈溢出：无穷无尽递归<br>栈结构：后进先出<br>方法：找重复（规模更小，子问题）-找变化（变化的量作为参数）-找边界（出口）</p>
<p>问题：</p>
<ul>
<li>翻转字符串</li>
</ul>
<h2 id="C-笔记"><a href="#C-笔记" class="headerlink" title="C++笔记"></a>C++笔记</h2><h2 id="字符串和字符数组字符指针"><a href="#字符串和字符数组字符指针" class="headerlink" title="字符串和字符数组字符指针"></a>字符串和字符数组字符指针</h2><p>warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="string">&quot;abc&quot;</span>; <span class="comment">//warning</span></span><br><span class="line"><span class="keyword">char</span>* p = (<span class="keyword">char</span>*)<span class="string">&quot;abc&quot;</span>;  <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *p = <span class="string">&quot;abc&quot;</span>;　　<span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>原因解释：</p>
<p>学习c或者c++的时候都知道，如果在赋值操作的时候，等号两边的变量类型不一样，那么编译器会进行一种叫做 implicit conversion 的操作来使得变量可以被赋值。<br>在上面的表达式中等号右边的”abc”是一个不变常量，在c++中叫做string literal，type是const char *，而p则是一个char指针。如果强行赋值会发生什么呢？没错，就是将右边的常量强制类型转换成一个指针，结果就是我们在修改一个const常量。编译运行的结果会因编译器和操作系统共同决定，有的编译器会通过，有的会抛异常，就算过了也可能因为操作系统的敏感性而被杀掉。<br>像这种直接将string literal 赋值给指针的操作被开发者们认为是deprecated，只不过由于以前很多代码都有这种习惯，为了兼容，就保留下来了。</p>
<ul>
<li><p>字符串字面值常量使用双引号括起的字符序列，以’\0’为结束符。它存放在内存的常量区，自己有固定的首地址。如果将字符串字面值常量的首地址看作指针，那么这个指针是常指针常量。字符串指针本身只读而且其指向的内容（字符串的内容）只读。</p>
</li>
<li><p>处理字符串有两种方式：字符串指针和字符数组</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str_arr[] = <span class="string">&quot;What a nice day!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*str_pt = <span class="string">&quot;What a nice day!&quot;</span>;</span><br><span class="line"><span class="comment">//字符数组</span></span><br><span class="line">字符数组本身是可写的，也就是说在完成初始化后，可以对其进行再次赋值。同样的，也可以不对它进行初始化，而是先声明后赋值。</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str_arr&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str_arr;</span><br><span class="line">这样的语句都是合法的，前者直接输出字符串内容；后者对字符数组进行二次赋值，原值被覆盖。但是不能直接用字符串字面值常量对字符数组名赋值，也不能用字符串指针或字符数组名对字符数组名赋值。即字符数组名不可放在赋值号左边。</span><br><span class="line">对于上面那个字符数组str_arr[]，它的大小，即<span class="keyword">sizeof</span>(str_arr)的值是<span class="number">17</span>，也就是数组内所存字符串的大小（包括’\<span class="number">0</span>’结束符）。</span><br><span class="line">如果在头文件下，输出<span class="built_in">strlen</span>(str_arr)的值，那么会输出<span class="number">16</span>，也就是字符串内容的长度（不包括’\<span class="number">0</span>’结束符）。</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str_arr[i]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(str_arr+i)&lt;&lt;<span class="built_in">endl</span>; 、</span><br><span class="line">那么会输出字符数组中第i个字符。</span><br><span class="line">这个地方有个有趣的事情是，字符数组str_arr[]中的空格并没有被编译器识别为’\<span class="number">0</span>’结束符。那是因为，事实上’\<span class="number">0</span>’结束符的编码是<span class="number">0x00</span>，字符类型中并没有’\<span class="number">0</span>’这个字符，它不是空格，而是一个空字符。</span><br><span class="line">但是如果程序中使用</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str_arr;</span><br><span class="line">这样的语句输入一行带空格的字符串时，str_arr只能接收到第一个单词，这是因为输入流对象<span class="built_in">cin</span>把空格（ascii码为<span class="number">0x20</span>）约定为了输入结束的标志。</span><br><span class="line"></span><br><span class="line">这个时候就应该使用逐行输入的函数了。在C的环境下，使用gets()函数是可行且便利的，但是vs2017中C++剔除了gets()函数，这样我们使用<span class="built_in">cin</span>.getline()函数来输入带空格的字符串。在这个实例下，程序中可写：</span><br><span class="line"><span class="built_in">cin</span>.getline(str_arr,<span class="number">17</span>,’\n’);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串指针</span></span><br><span class="line">使用字符串指针处理的情况下，该字符串指针是是一个常指针。</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str_pt&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">是可行的，但是</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str_pt; </span><br><span class="line">是非法的（尽管编译器并不识别该错误，但是运行时会出错）。、</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*str_pt= <span class="string">&quot;What a nice day!&quot;</span>;</span><br><span class="line">str_pt = <span class="string">&quot;Yes,it is.&quot;</span>;</span><br><span class="line">这样的语句，也是可行的。常指针指向的地址可改（即可以通过给指针二次赋值指向不同地址），仅仅是不能通过指针修改其指向的内容。再加上，字符串字面值常量本身是一个常指针常量，它可以赋给字符串指针，那么同理，字符数组名这个指针常量赋给字符串指针合法也是理所当然的了。</span><br><span class="line">尽管字符串指针指向其所储存的字符串字面值常量的首地址，但是</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str_pt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">并不输出该地址，而是输出整个字符串。如果想要获得该地址，则需要这样写代码：</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="keyword">void</span>*)str_pt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str3[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str4[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str5 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str6 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (str1 == str2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (str4 == str3) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (str5 == str6) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (str1 == str6) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-遍历字符串的三种方式"><a href="#C-遍历字符串的三种方式" class="headerlink" title="C++遍历字符串的三种方式"></a>C++遍历字符串的三种方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一，常规下标方式</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt1</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            value *= <span class="number">10</span>;</span><br><span class="line">            value += str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; StrToInt1(<span class="string">&quot;1234&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二，迭代器</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt2</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//迭代器--在STL中，不破坏封装的情况下去访问容器</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span>::iterator it = str.begin();<span class="comment">//返回第一个位置的迭代器（类似于指针）</span></span><br><span class="line">        <span class="keyword">while</span> (it != str.end())<span class="comment">//str.end()是最后一个数据的下一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            value *= <span class="number">10</span>;</span><br><span class="line">            value += (*it - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;<span class="comment">//顺序表的迭代器</span></span><br><span class="line">        v.push_back(<span class="number">1</span>);</span><br><span class="line">        v.push_back(<span class="number">2</span>);</span><br><span class="line">        v.push_back(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vit = v.begin();</span><br><span class="line">        <span class="keyword">while</span> (vit != v.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *vit &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">            vit++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; StrToInt2(<span class="string">&quot;1234&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三，新式for循环</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt3</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str)<span class="comment">//ch依次取的是str里面的字符,直到取完为止</span></span><br><span class="line">        &#123;</span><br><span class="line">            value *= <span class="number">10</span>;</span><br><span class="line">            value += (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; StrToInt3(<span class="string">&quot;1234&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意新式for循环的底层是用for循环实现的</span></span><br></pre></td></tr></table></figure>
<h2 id="string的详细用法"><a href="#string的详细用法" class="headerlink" title="string的详细用法"></a>string的详细用法</h2><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str; <span class="comment">//生成一个空的字符串</span></span><br><span class="line"><span class="comment">//还有其他声明方法</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, stridx)</span></span>;  <span class="comment">// 将字符串str内&quot;始于位置stridx&quot;的部分当作字符串的初值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, stridx, <span class="built_in">strlen</span>)</span> </span>; <span class="comment">// 将字符串str内&quot;始于stridx且长度顶多strlen&quot;的部分作为字符串的初值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr)</span> </span>;  <span class="comment">// 将C字符串（以NULL结束）作为s的初值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(chars, chars_len)</span> </span>;  <span class="comment">// 将C字符串前chars_len个字符作为字符串s的初值。</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(num, ‘c’)</span> </span>;  <span class="comment">// 生成一个字符串，包含num个c字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(“value”)</span></span>;  <span class="built_in">string</span> s=“value”;  <span class="comment">// 将s初始化为一个字符串字面值副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(begin, end)</span></span>;  <span class="comment">// 以区间begin/end(不包含end)内的字符作为字符串s的初值</span></span><br><span class="line">s.~<span class="built_in">string</span>();  <span class="comment">//销毁所有字符，释放内存</span></span><br></pre></td></tr></table></figure>
<h2 id="与字符数组的比较"><a href="#与字符数组的比较" class="headerlink" title="与字符数组的比较"></a>与字符数组的比较</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">string</th>
<th style="text-align:center">字符阵列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">声明</td>
<td style="text-align:center">string s</td>
<td style="text-align:center">char s[100]</td>
</tr>
<tr>
<td style="text-align:center">取字符</td>
<td style="text-align:center">s[i]</td>
<td style="text-align:center">s[i]</td>
</tr>
<tr>
<td style="text-align:center">字符串长度</td>
<td style="text-align:center">s.length()；s.size()</td>
<td style="text-align:center">strlen(s) 不计 \0</td>
</tr>
<tr>
<td style="text-align:center">读取一行</td>
<td style="text-align:center">getline(cin,s)</td>
<td style="text-align:center">gets(s)</td>
</tr>
<tr>
<td style="text-align:center">设成某字符串</td>
<td style="text-align:center">s=”tgs”</td>
<td style="text-align:center">strcpy(s,”tgs”)</td>
</tr>
<tr>
<td style="text-align:center">字符串相加</td>
<td style="text-align:center">s+=”tgs”</td>
<td style="text-align:center">strcat(s,:”tgs”)</td>
</tr>
<tr>
<td style="text-align:center">字符串比较</td>
<td style="text-align:center">s==”tgs”</td>
<td style="text-align:center">strcmp(s,”tgs”)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="string对象的操作"><a href="#string对象的操作" class="headerlink" title="string对象的操作"></a>string对象的操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s.empty();  <span class="comment">// s为空串 返回true</span></span><br><span class="line">s.size();  <span class="comment">// 返回s中字符个数 类型应为：string::size_type</span></span><br><span class="line">s[n];  <span class="comment">// 从0开始相当于下标访问</span></span><br><span class="line">s1+s2;  <span class="comment">// 把s1和s2连接成新串 返回新串 </span></span><br><span class="line">s1=s2;  <span class="comment">// 把s1替换为s2的副本</span></span><br><span class="line">v1==v2;  <span class="comment">// 比较，相等返回true</span></span><br><span class="line"><span class="comment">//`!=, &lt;, &lt;=, &gt;, &gt;=`  惯有操作 任何一个大写字母都小于任意的小写字母</span></span><br></pre></td></tr></table></figure>
<h2 id="与字符串字面使用"><a href="#与字符串字面使用" class="headerlink" title="与字符串字面使用"></a>与字符串字面使用</h2><p>当进行string对象和字符串字面值混合连接操作时，+操作符的左右操作数必须至少有一个是string类型的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(“hello”)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s3=s1+”world”;  <span class="comment">//合法操作</span></span><br><span class="line"><span class="built_in">string</span> s4=”hello”+”world”;  <span class="comment">//非法操作：两个字符串字面值相加</span></span><br></pre></td></tr></table></figure>
<h2 id="string函数"><a href="#string函数" class="headerlink" title="string函数"></a>string函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) =, s.assign() <span class="comment">// 赋以新值 </span></span><br><span class="line"><span class="number">2</span>) swap() <span class="comment">// 交换两个字符串的内容 </span></span><br><span class="line"><span class="number">3</span>) +=, s.append(), s.push_back() <span class="comment">// 在尾部添加字符 </span></span><br><span class="line"><span class="number">4</span>) s.insert() <span class="comment">// 插入字符 </span></span><br><span class="line"><span class="number">5</span>) s.erase() <span class="comment">// 删除字符 </span></span><br><span class="line"><span class="number">6</span>) s.clear() <span class="comment">// 删除全部字符 </span></span><br><span class="line"><span class="number">7</span>) s.replace() <span class="comment">// 替换字符 </span></span><br><span class="line"><span class="number">8</span>) + <span class="comment">// 串联字符串 </span></span><br><span class="line"><span class="number">9</span>) ==,!=,&lt;,&lt;=,&gt;,&gt;=,compare() <span class="comment">// 比较字符串 </span></span><br><span class="line"><span class="number">10</span>) size(),length() <span class="comment">// 返回字符数量 </span></span><br><span class="line"><span class="number">11</span>) max_size() <span class="comment">// 返回字符的可能最大个数 </span></span><br><span class="line"><span class="number">12</span>) s.empty() <span class="comment">// 判断字符串是否为空 </span></span><br><span class="line"><span class="number">13</span>) s.capacity() <span class="comment">// 返回重新分配之前的字符容量 </span></span><br><span class="line"><span class="number">14</span>) reserve() <span class="comment">// 保留一定量内存以容纳一定数量的字符 </span></span><br><span class="line"><span class="number">15</span>) [ ], at() <span class="comment">// 存取单一字符 </span></span><br><span class="line"><span class="number">16</span>) &gt;&gt;,getline() <span class="comment">// 从stream读取某值 </span></span><br><span class="line"><span class="number">17</span>) &lt;&lt; <span class="comment">// 将谋值写入stream </span></span><br><span class="line"><span class="number">18</span>) copy() <span class="comment">// 将某值赋值为一个C_string </span></span><br><span class="line"><span class="number">19</span>) c_str() <span class="comment">// 返回一个指向正规C字符串(C_string)的指针 内容与本string串相同 有’\0’ </span></span><br><span class="line"><span class="number">20</span>) data() <span class="comment">// 将内容以字符数组形式返回 无’\0’ </span></span><br><span class="line"><span class="number">21</span>) s.substr() <span class="comment">// 返回某个子字符串 </span></span><br><span class="line"><span class="number">22</span>) begin() end() <span class="comment">// 提供类似STL的迭代器支持 </span></span><br><span class="line"><span class="number">23</span>) rbegin() rend() <span class="comment">// 逆向迭代器 </span></span><br><span class="line"><span class="number">24</span>) get_allocator() <span class="comment">// 返回配置器</span></span><br></pre></td></tr></table></figure>
<h2 id="插入字符"><a href="#插入字符" class="headerlink" title="插入字符"></a>插入字符</h2><p>也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。<br>s.insert(0,”my name”);<br>s.insert(1,str);<br>这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式。为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：<br>insert(size_type index, size_type num, chart c)和insert(iterator pos, size_type num, chart c)。<br>其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：<br>insert(0, 1, ‘j’);这时候第一个参数将转换成哪一个呢？<br>所以你必须这么写：insert((string::size_type)0, 1, ‘j’)！<br>第二种形式指出了使用迭代器安插字符的形式。</p>
<h2 id="从提取子字符串"><a href="#从提取子字符串" class="headerlink" title="从提取子字符串"></a>从提取子字符串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.substr(); <span class="comment">// 返回s的全部内容 </span></span><br><span class="line">s.substr(<span class="number">11</span>); <span class="comment">// 从索引11往后的子串 </span></span><br><span class="line">s.substr(<span class="number">5</span>,<span class="number">6</span>); <span class="comment">// 从索引5开始6个字符</span></span><br></pre></td></tr></table></figure>
<h2 id="string到int的转换"><a href="#string到int的转换" class="headerlink" title="string到int的转换"></a>string到int的转换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">    str1=<span class="string">&quot;100&quot;</span>;</span><br><span class="line">    <span class="built_in">stringstream</span> stream;</span><br><span class="line">    stream&lt;&lt;str1;</span><br><span class="line">    stream&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="每日函数"><a href="#每日函数" class="headerlink" title="每日函数"></a>每日函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">：</span><br><span class="line">：</span><br><span class="line">：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="计蒜客"><a href="#计蒜客" class="headerlink" title="计蒜客"></a>计蒜客</h2><p>蔡基姆拉尔森计算公式：快速计算星期几</p>
<p>printf(%04d):4指输出的长度，0指不足的在前面补</p>
<p>空格处理方法：第一种知道多少输出先输出ans+空格，最后一个输出ans；第二种不知道多少个输出第一个输出ans，其后均输出空格+ans</p>
<p>string字符串可以使用&gt;&lt;进行大小比较</p>
<p>EPSILON = 1e-6</p>
<p>当使用字符串的时候不知道其大小范围最好使用string类型</p>
<p>当输入输出数据过大时cin,cout可能会超时，此时应该使用scanf和printf</p>
<p>string大写转小写<br>string ss;<br>for (int i = 0; i &lt; ss.size(); i++) {<br>    if (ss[i] &gt;= ‘A’ &amp;&amp; ss[i] &lt;= ‘Z’) {<br>        ss[i] = ‘a’ + (ss[i] - ‘A’);<br>    }<br>}</p>
<h3 id="使用sort进行数组排序"><a href="#使用sort进行数组排序" class="headerlink" title="使用sort进行数组排序"></a>使用sort进行数组排序</h3><p>sort可以进行数组排序，也可以排序自己定义的结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//!!!api文档中没有头文件</span></span><br><span class="line"><span class="comment">//arr开始元素到第5个元素</span></span><br><span class="line">sort(arr,arr+<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr[i]到arr[j]</span></span><br><span class="line">sort(arr+i,arr j+<span class="number">1</span>)  <span class="comment">//j =  下标+1等于此时是第几个</span></span><br><span class="line"><span class="comment">//默认从小到大排</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排</span></span><br><span class="line">sort(arr, arr+<span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="comment">//第三个参数是排序方法grater表示更大,int表示整数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序方案</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line"><span class="comment">//x大于y，x便在前面否则y在前面</span></span><br><span class="line"><span class="comment">//return什么就是什么成立</span></span><br><span class="line"><span class="comment">//此处不能有等于，容易出现错误</span></span><br><span class="line"><span class="comment">//等于的时候一定给false</span></span><br><span class="line">&#125;</span><br><span class="line">sort(arr, arr+i, cmp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体可以使用构造函数来进行初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    student() &#123;&#125; <span class="comment">//无参的默认构造函数，什么都不做</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表:赋值的更简单方法，只赋值不进行其他操作</span></span><br><span class="line">    student(<span class="built_in">string</span> n, <span class="keyword">int</span> s): name(n), score(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>根据提出的问题，列出该问题所有的可能解，并在逐一列出的过程中检查该解是否为问题的真正解。</p>
<p>解枚举范围必须是有穷的<br>检验条件是确定的</p>
<h2 id="递-归"><a href="#递-归" class="headerlink" title="递 归"></a>递 归</h2><p>递归设计经验</p>
<ul>
<li>找重复</li>
<li>找重复中的变量</li>
<li>找参数变化趋势：设计出口</li>
</ul>
<p>递归是栈结构</p>
<ul>
<li>斐波拉契数列：递归指数级复杂度</li>
<li>汉诺塔问题</li>
</ul>
<h2 id="二分查找的递归解法"><a href="#二分查找的递归解法" class="headerlink" title="二分查找的递归解法"></a>二分查找的递归解法</h2><h2 id="深度优先搜素"><a href="#深度优先搜素" class="headerlink" title="深度优先搜素"></a>深度优先搜素</h2><p>简称dfs，是一个经典的搜索算法。<br>我们要将dfs和递归联系起来<br>这里的搜索是一种穷举的方式，即把所有的可行方案都列举出来，不断去尝试直到找到正确的答案。<br>递归是一种编程语言的实现，而深度搜索是一种思想，深度搜索可以使用递归实现。</p>
<p>搜索过程对应着一棵树，我们将其称为搜索树。<br>返回上一步的过程称为回溯</p>
<h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><h2 id="计蒜客刷题"><a href="#计蒜客刷题" class="headerlink" title="计蒜客刷题"></a>计蒜客刷题</h2><ul>
<li><p>倍数<br>注意int的取值范围</p>
</li>
<li><p>找质数<br>筛法求素数<br>cin和cout效率不如scanf和printf</p>
</li>
<li><p>阶梯三角形<br>这种代码填空题要先弄明白每个变量的含义，不能先入为主</p>
</li>
</ul>
<h1 id="集训"><a href="#集训" class="headerlink" title="集训"></a>集训</h1><h2 id="历年真题"><a href="#历年真题" class="headerlink" title="历年真题"></a>历年真题</h2><h3 id="2019B组省赛"><a href="#2019B组省赛" class="headerlink" title="2019B组省赛"></a>2019B组省赛</h3><h4 id="组队"><a href="#组队" class="headerlink" title="组队"></a>组队</h4><ul>
<li>程序解决<br>因为是五个人组队故可以使用5层for循环解决，中间判断5人不能为同一人。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="I后缀表达式"><a href="#I后缀表达式" class="headerlink" title="I后缀表达式"></a>I后缀表达式</h4><p>本题与后缀表达式相关知识关系buda<br><strong>解题思路</strong>：经过归纳总结对题中出现的几种情况进行分别讨论</p>
<h1 id="语言基础篇"><a href="#语言基础篇" class="headerlink" title="语言基础篇"></a>语言基础篇</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p><strong>函数模板的格式</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 形参名, <span class="keyword">class</span> 形参名, ......&gt;</span> 返回值类型 函数名(参数列表)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位运算的奇巧淫技：</p>
<ul>
<li>判断奇偶性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x &amp; <span class="number">1</span> == <span class="number">1</span>; <span class="comment">//奇数：奇数二进制最低位必为1</span></span><br><span class="line">x &amp; <span class="number">1</span> == <span class="number">0</span>; <span class="comment">//偶数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取二进制位是1还是0：通过左移1的位置，原理同上</li>
<li>交换两个整型变量的值：做三次异或操作</li>
<li>不用判断语句求整数的绝对值</li>
<li>拓展：异或操作可以理解为不进位加法，相同为0不同为1</li>
</ul>
<p>问题：</p>
<ul>
<li>将1-1000这些个数放在一个1001个元素的数组中，只有唯一的一个元素重复。每个元素只能访问一次，设计一个算法找出这个数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">方案<span class="number">1</span>：</span><br><span class="line"><span class="comment">// A ^ A == 0;</span></span><br><span class="line"><span class="comment">// B ^ 0 == B;  是1的位还为1是0的还为0</span></span><br><span class="line"><span class="comment">// A ^ B ^ C == A ^ C ^ B </span></span><br><span class="line"><span class="comment">//满足交换律：本质看同一位01的个数为奇数还是偶数</span></span><br><span class="line"><span class="number">1</span>^<span class="number">2</span>^...^<span class="number">1001</span> ^(<span class="number">1</span>^<span class="number">2</span>^..<span class="number">.1000</span>);</span><br><span class="line"></span><br><span class="line">方案<span class="number">2</span>；</span><br><span class="line">扫描技术法：开一个数组，用存数数组的元素作为该数组的下标，没出现一次便加一操作</span><br></pre></td></tr></table></figure>
<ul>
<li>输入一个整数，输出该数二进制中1的个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">设输入量为x</span><br><span class="line">方案<span class="number">1</span>：</span><br><span class="line">做&amp;运算并向左移动<span class="number">1</span>的位置</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    x &amp; i != <span class="number">0</span>; <span class="comment">//此时计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方案<span class="number">2</span>；右移x</span><br><span class="line"></span><br><span class="line">方案<span class="number">3</span>：经典：消掉<span class="number">1</span></span><br><span class="line">假设：<span class="number">100100</span>   将其进行<span class="number">-1</span>操作</span><br><span class="line">     -     <span class="number">1</span></span><br><span class="line">      <span class="number">100011</span>   变化由于借位原为<span class="number">1</span>的最低为变为<span class="number">0</span>其后<span class="number">0</span>变为<span class="number">1</span></span><br><span class="line"></span><br><span class="line">      <span class="number">100100</span></span><br><span class="line">    &amp; <span class="number">100011</span></span><br><span class="line">      <span class="number">100000</span>  继续进行<span class="number">-1</span>作与运算看做多少次后为<span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用一条语句判断一个整数是不是2的整数次方</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">观察<span class="number">2</span>的整数次方<span class="number">2</span>进制：<span class="number">1</span>，<span class="number">10</span>，<span class="number">100</span>，<span class="number">1000</span></span><br><span class="line">总结：只有一个<span class="number">1</span></span><br><span class="line">结合上题方案<span class="number">3</span>，有一个<span class="number">1</span>只能做一次减一作与操作</span><br><span class="line"><span class="keyword">if</span>(x&amp;(x<span class="number">-1</span>)==<span class="number">0</span>) <span class="comment">//便为2整数次方</span></span><br></pre></td></tr></table></figure>
<ul>
<li>整数二进制奇偶位呼唤</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  mmmmmmmm      mmmmmmmm</span><br><span class="line"> &amp;<span class="number">01010101</span>     &amp;<span class="number">10101010</span></span><br><span class="line">  0x0x0x0x      y0y0y0y0</span><br><span class="line">  偶数位        奇数位</span><br><span class="line">  x0x0x0x0      0y0y0y0y    分别左移右移</span><br><span class="line"></span><br><span class="line">  x0x0x0x0</span><br><span class="line">  0y0y0y0y  按位或或者按位异或操作</span><br><span class="line"></span><br><span class="line">拓展：<span class="number">0b1010</span> = <span class="number">0xa</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">0b1001</span>;</span><br><span class="line">  <span class="keyword">int</span> x = m &amp; <span class="number">0b01010101</span>;</span><br><span class="line">  <span class="keyword">int</span> y = m &amp; <span class="number">0b10101010</span>;</span><br><span class="line">  x = x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  y = y &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  m = x | y;</span><br><span class="line">  cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>0-1间浮点数的二进制表示：给定一个介于0-1之间的实数，打印它的二进制表示，如果该数无法用32位以内的二进制表示则打印error</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span>二进制表示：除<span class="number">2</span>得七余<span class="number">1</span>，最低为填<span class="number">1</span>，同理次地位填<span class="number">1.</span>.<span class="number">.1111</span>从后往前填</span><br><span class="line"></span><br><span class="line"><span class="number">0.625</span>二进制表示：乘以<span class="number">2</span>得<span class="number">1.25</span> 在<span class="number">0.</span>后面填第一个<span class="number">1</span>，<span class="number">0.25</span>乘以<span class="number">2</span>得<span class="number">0.5</span>次高位填<span class="number">0.</span>... <span class="number">0.1010</span>。(<span class="number">0.05</span>,<span class="number">0.25</span>,<span class="number">0.125</span> .....)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数组中一个数只出现了1次，其他出现了k次找出出现了一次的数</p>
<p>两个相同的二进制数做不进位加法结果为0<br>十个相同的十进制数做不进位加法结果为0</p>
</li>
</ul>
<h2 id="常用STL的使用"><a href="#常用STL的使用" class="headerlink" title="常用STL的使用"></a>常用STL的使用</h2><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>当我们想要开一个数组，但不知道开多大合适。我们可以使用C++中的动态数组vector</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//必须有</span></span><br><span class="line"><span class="comment">//C++中直接构造和一个vector的语句：vector&lt;T&gt; vec</span></span><br><span class="line"><span class="comment">//定义了一个名为vec储存T类型数据的动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改  </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;   <span class="comment">//&#123;&#125;</span></span><br><span class="line">vec.push_back(<span class="number">1</span>);  <span class="comment">//&#123;1&#125;</span></span><br><span class="line">vec.push_back(<span class="number">12</span>;  <span class="comment">//&#123;1， 2&#125;</span></span><br><span class="line">vec[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vec[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素，只支持删除尾端：C++中使用pop_back()方法删除动态数组的最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空：只需要调用clear()函数</span></span><br><span class="line"><span class="comment">//clear()只是清空vector，并不会清空来内存，下面的方法可以清空开内存：</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;.swap(vec);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//高级用法</span></span><br><span class="line"><span class="comment">//用vector存储自定义的数据类型：比如说结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n)</span><br><span class="line"><span class="comment">//n表示初始的长度，1表示初始化元素均为1，如果不传入第二个元素初始化为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维动态数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec <span class="comment">//此处有一个空格防止与右移运算符发生冲突</span></span><br><span class="line"><span class="comment">//理解为：外vector中的类型为 vector&lt;int&gt;类型</span></span><br><span class="line"><span class="comment">//二维动态数组的每一维的长度都可以不一样，可以是任意形状的。</span></span><br><span class="line"><span class="comment">//借助构造函数我们可以快速构造一个n行m的动态数组，每个元素的初始值为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组有一种常见的错误写法</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    vec[i].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问的时候会出现访问非法内存，因为第一维的大小为0</span></span><br></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>由不重复数据组成的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;Y&gt; s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素 insert()</span></span><br><span class="line"><span class="comment">//集合中已经存在了某个元素，再次插入不会产生任何效果，集合中是不会有重复出现的元素的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素 erase()</span></span><br><span class="line"><span class="comment">//如果集合中不存在这个元素不会进行任何操作且不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断元素是否存在 count()</span></span><br><span class="line"><span class="comment">//如果集合中找到则返回1否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="comment">//C++可以通过迭代器访问集合中的每个元素，迭代器就好像一根手指指向set中的元素</span></span><br><span class="line"><span class="comment">//通过 * (解引用运算符) 操作可以获取迭代器指向的元素</span></span><br><span class="line"><span class="comment">//通过++或者)--操作让迭代器指向下一个或者上一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器的写法比较固定</span></span><br><span class="line"><span class="built_in">set</span>&lt;T&gt;::iterator it;</span><br><span class="line"><span class="comment">//就定义了指向set&lt;T&gt; 这种集合的迭代器</span></span><br><span class="line">begin()  <span class="comment">//返回容器中起始元素的迭代器</span></span><br><span class="line">end()    <span class="comment">//返回容器的尾后迭代器(已经超出集合范围，进行--操作可以得到最后一个元素)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：在C++中遍历set是从小到大的，也就是说set会帮我们排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作</span></span><br><span class="line">clear()</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 set 中插入删除和查找某个元素的时间复杂度都是 O(log n)，并且内部元素是有序的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配合结构体使用</span></span><br><span class="line"><span class="comment">//set是需要经过排序的，系统自带的数据类型有默认比较大小的规则</span></span><br><span class="line"><span class="comment">//而我们定义的结构体，系统不知道比较大小的规则</span></span><br><span class="line"><span class="comment">//我们可以采用运算符重载，重新定义小于号，告诉系统比较大小的规则</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == rhs.x) &#123;</span><br><span class="line">            <span class="keyword">return</span> y &lt; rhs.y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x &lt; rhs.x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rhs表示右操作数。因为该运算符重载定义在结构体内部，左操作数就是当前调用operator&lt;的对象</span></span><br><span class="line"><span class="comment">//不能漏掉最后的const。const函数表示不能对其数据成员进行修改操作</span></span><br><span class="line"><span class="comment">//并且const对象不能调用非const成员函数</span></span><br></pre></td></tr></table></figure>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射是指两个集合之间的元素的相互对应关系：姓名和班级。我们称姓名集合为<strong>关机键集合(key)</strong>，班级集合为<strong>值集合(value)</strong>。<br>在C++中我们常用的映射是map</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;T1, T2&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一对映射</span></span><br><span class="line"><span class="comment">//在C++中通过insert()函数向集合中插入一个新的映射，参数是一个 pair 。</span></span><br><span class="line"><span class="comment">//pair是一个标准库类型，定义在头文件utility中</span></span><br><span class="line"><span class="comment">//可以看作是有两个成员变量first和second的结构体</span></span><br><span class="line"><span class="comment">//并且重载了&lt;运算符</span></span><br><span class="line"><span class="comment">//当我们创建一个pair时必须提供两个类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="comment">//make_pair(v1, v2)函数返回由v1和v2初始化的pair</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="string">&quot;mike&quot;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">//如果插入的key之前已经存在了，则不会插入新的value替代原本的value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问映射</span></span><br><span class="line"><span class="comment">//直接使用[]进行访问</span></span><br><span class="line">m[<span class="string">&quot;mike&quot;</span>]; <span class="comment">//1</span></span><br><span class="line"><span class="comment">//如果m[&quot;x&quot;],x没有做过映射的话系统会自动生成一个x的映射，其对应的value为默认值。例如int的话为0。</span></span><br><span class="line"><span class="comment">//可以对映射赋予新的value</span></span><br><span class="line">m[<span class="string">&quot;x&quot;</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//有些时候我们并不希望系统为我们自动生成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断映射是否存在</span></span><br><span class="line">count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历映射</span></span><br><span class="line"><span class="comment">//使用迭代器进行访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">    it-&gt;first;</span><br><span class="line">    *it.second;</span><br><span class="line"><span class="comment">//这两种方式是一样的</span></span><br><span class="line"><span class="comment">//map是按照关键字从小到大遍历的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维map</span></span><br><span class="line"><span class="comment">//map不仅有map套map还有map套set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map套set</span></span><br><span class="line"><span class="comment">//记录全校学生的姓名但，难免会有重复的名字，我们可以对每个班级创建一个set，每个班级创建一个set，这样就能分辨不同班级的同名同学了</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &gt; s;</span><br><span class="line"><span class="comment">//此时我们就可以进行插入删除和查询操作了</span></span><br><span class="line"><span class="comment">//s[2]表示2班对应的姓名集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map套map</span></span><br><span class="line"><span class="comment">//此时无法解决同班同名的情况</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line"><span class="comment">//用第二维的int记录一个名字有多少个同学</span></span><br></pre></td></tr></table></figure>
<h3 id="栈和递归"><a href="#栈和递归" class="headerlink" title="栈和递归"></a>栈和递归</h3><p>满足一定约束的线性数据结构。其约束是：只允许在栈的一段插入和删除数据，这一端被称为栈顶；相对的，我们把另一端称为栈底。<br>该过程类似与子弹匣，当我们往其压入子弹时我们称之为<strong>push</strong>；射击子弹的时候，我们称之为<strong>pop</strong>。<br><strong>性质：先进后出，后进先出</strong><br>为了方便我们常用一个top来指示栈顶的位置</p>
<p>通常我们会把数据结构封装起来：将栈写成一个class或者struct</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">if</span>(top &lt; <span class="number">10000</span>)</span><br><span class="line">            data[top] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;栈溢出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(top &gt;= <span class="number">0</span>)</span><br><span class="line">          top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">topval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> data[top];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>STL中也有定义完的stack。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="comment">//除了支持pop和push等基本操作，还支持top()来获取栈顶元素</span></span><br><span class="line"><span class="comment">//empty()判断栈是否为空，size()计算栈中元素的个数</span></span><br></pre></td></tr></table></figure>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p><em>C++中一些常用的函数。</em><br>|函数|头文件|规范|作用|<br>|:-:|:-:|:-:|:-:|<br>|append()||||<br>|sprintf()||||<br>|_itoa()||||<br>sizeof(array)/size(a[0])||||<br>|gets()||||<br>|fgets()||||<br>|round()||||<br>|unique()：注意使用时需要进行排序且其去重后长度||||<br>|swap()||||<br>|next_permutation()：全排列||||<br>|reverse()函数把list所有元素倒转。||||<br>|string str=”hello world , hi”;||||<br>|reverse(str.begin(),str.end());//str结果为 ih , dlrow olleh||||<br>|<code>vector&lt;int&gt;</code> v = {5,4,3,2,1};||||<br>|reverse(v.begin(),v.end());//容器v的值变为1,2,3,4,5||||</p>
<h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><p><em>算法！</em></p>
<h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><p><strong>二叉树的递归定义</strong>：二叉树要么为空，要么由 root 、left subtree 、right subtree 组成，而左右子树分别又是一棵二叉树，计算机中树一般倒置。</p>
<p><strong>树</strong>：；树和二叉树类似，区别在于每个结点不一定只有两棵子树。</p>
<h3 id="二叉树编号"><a href="#二叉树编号" class="headerlink" title="二叉树编号"></a>二叉树编号</h3><ul>
<li>对于每一个结点k，其左子节点和右子节点的编号分别为是2k和2k+1。</li>
<li>给定一棵包含$2^d$个节点(d为树的高度)的完全二叉树，从1开始编号，d层的首个节点为$2^{d-1}$，末尾节点为$2^{d}-1$</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="二叉树宽度优先遍历-bfs"><a href="#二叉树宽度优先遍历-bfs" class="headerlink" title="二叉树宽度优先遍历 bfs"></a>二叉树宽度优先遍历 bfs</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> have_value;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    Node():have_value(<span class="literal">false</span>), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照层次顺序遍历这棵树。此处使用队列，初始时只用一个根节点，然后每次取出一个父节点，就把他的左右子节点放入队列中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">ans.clear();</span><br><span class="line">q.push(root); <span class="comment">//初始时只有一个根结点</span></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">Node* u = q.front(); q.pop();</span><br><span class="line"><span class="keyword">if</span>(!u-&gt;have_value) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//有结点没有被赋值过，表明输入有误</span></span><br><span class="line">ans.push_back(u-&gt;v); <span class="comment">//增加到输出序列尾部</span></span><br><span class="line"><span class="keyword">if</span>(u-&gt;left != <span class="literal">NULL</span>) q.push(u-&gt;left); <span class="comment">//把左子结点（如果有）放进队列</span></span><br><span class="line"><span class="keyword">if</span>(u-&gt;right != <span class="literal">NULL</span>) q.push(u-&gt;right); <span class="comment">//把右子结点（如果有）放进队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//输入正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的深度优先遍历-dfs"><a href="#二叉树的深度优先遍历-dfs" class="headerlink" title="二叉树的深度优先遍历 dfs"></a>二叉树的深度优先遍历 dfs</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>Graph 描述的是一些个体之间的关系。与线性表和二叉树不同的是：这些个体之间既不是前驱后继的顺序关系，也不是祖先后代的层次关系，而是错综复杂的网状关系。</p>
<h3 id="用-bfs-求最短路径"><a href="#用-bfs-求最短路径" class="headerlink" title="用 bfs 求最短路径"></a>用 bfs 求最短路径</h3><p>按层遍历，每增加一层意味着增加一步，故第一次遍历到目的节点的层数为代表的步数为最短路径。</p>
<ul>
<li>迷宫问题</li>
</ul>
<p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210319105542812.png" alt="image-20210319105542812"></p>
<p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210319111251977.png" alt="image-20210319111251977"><br>使用bfs求出图的最短路之后，可以用递归方式打印最短的具体路径。如果路径非常长，递归可能会引起栈溢出，此时可以改用循环，用vector保存路径。</p>
<h2 id="波兰表达式"><a href="#波兰表达式" class="headerlink" title="波兰表达式"></a>波兰表达式</h2><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><ul>
<li>逆波兰表达式的计算</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算逆波兰表达式的值即后缀表达式的值可以使用栈进行计算</span></span><br><span class="line"><span class="comment">//原理:向栈中push数字当遇到计算符号时pop最上层两个数字进行计算后push</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;123+-&quot;</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ss；</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(s[i] &gt;= <span class="string">&#x27;0&#x27;</span>  &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        y = ss.top();  <span class="comment">//注意：先弹出的为后操作数</span></span><br><span class="line">        ss.pop();</span><br><span class="line">        x = ss.top();</span><br><span class="line">        ss.pop();     <span class="comment">//注意：两个操作数都要pop</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            ss.push(x + y);</span><br><span class="line">        <span class="keyword">if</span>*(s[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            ss.push(x - y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ss.push(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ss.yop() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="调度场算法"><a href="#调度场算法" class="headerlink" title="调度场算法"></a>调度场算法</h3><p>为了把较难处理的中缀表达式转化为容易处理的后缀表达式，引入调度场算法。<br>中缀表达式之所以难处理本质上因为优先级。如果我们把所有表达式全部按优先级加上括号，就很容易按照递归进行计算，但是这并不好实现。<br>因此我们换一种思路用栈来解决问题。</p>
<p><strong>使用栈的原因</strong>：当我们读到<code>a + b</code>的时候并不知道后面是什么，我们需要暂缓一步，等有了足够的信息再将其放出来。<br>足够的信息：假设<strong>乘方</strong>是优先级最高的运算，当我们读到<code>a ^ b</code>时无论后面是什么操作都可以立刻将其变为<code>a b ^</code>，但是当我们遇到其他计算就要考虑后面的计算符号，若是低于他的则可放心进行计算。</p>
<p><strong>归纳</strong>：栈顶的运算符被弹出的条件是<strong>优先级不低于新读入的运算符</strong>。当表达式结束时，也要把栈里剩余的运算符依次弹出。</p>
<p><strong>算法</strong>：</p>
<ol>
<li>读到数字：直接输出</li>
<li>读到运算符：如果栈顶的运算符优先级不低于(大于等于)该运算符，则输出栈顶的运算符并使之出栈，直到栈空或不满足上述条件为止；然后入栈。</li>
<li>当读入完毕时，依次输出并弹出栈顶运算符，直到栈被清空。</li>
</ol>
<p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/v2-5d60fe34ae244a296cd3562617facea7_r.png" alt="v2-5d60fe34ae244a296cd3562617facea7_r"></p>
<p><strong>处理括号</strong>：</p>
<ol>
<li>读到数字：直接输出</li>
<li>读到一般运算符：果栈顶的运算符优先级不低于(大于等于)该运算符，则输出栈顶的运算符并使之出栈，直到栈空或不满足上述条件为止；然后入栈。</li>
<li>读到左括号：直接入栈</li>
<li>读到右括号：输出栈顶运算符并使之出栈知道栈顶为左括号为止，令左括号出栈。实质：一个括号实际上就是重新建一个栈进行括号内的调度场算法</li>
<li>当读入完毕时，依次输出并弹出栈顶运算符直到栈被清空<br>奇巧淫技：可以在表达式的最末尾加上一个<code>#</code>将其优先级定义为最低，遇到此运算符时即为表达式的结尾</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">    &#125;data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;pri;</span><br><span class="line">pri[<span class="string">&#x27;+&#x27;</span>] = pri[<span class="string">&#x27;-&#x27;</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> <span class="built_in">exp</span>, node postP[N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0.</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exp</span> += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">    <span class="keyword">while</span>(q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(str[i]))&#123;</span><br><span class="line">            t = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>[++i])&#123;</span><br><span class="line">                t = t*<span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            postP[cnt].data.num = t;</span><br><span class="line">            postP[cnt++].tag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk,empty() &amp;&amp; pri[str[i]] &gt; pri[stk.top()]) &#123;</span><br><span class="line">                postP[cnt]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="fropen"><a href="#fropen" class="headerlink" title="fropen"></a>fropen</h3><p>头文件 <stdio.h></stdio.h></p>
<p>fropen(path, mode, stream)</p>
<p>path:路径<br>mode:文件打开方式”r”-只读， “w”-写<br>stream:stdin-标准输入流,stdout-标准输出流</p>
<h2 id="动态规划初步"><a href="#动态规划初步" class="headerlink" title="动态规划初步"></a>动态规划初步</h2><ul>
<li>状态及状态转移方程</li>
<li>最优子结构和重叠子问题</li>
<li>递推法和记忆化搜素求解数字三角形问题</li>
<li>DAG上动态规划的常见思路、两种状态定义的方法和刷表法</li>
<li>记忆化搜索再实现方面的注意事项</li>
<li>记忆化搜索和递推中输出方案的方法</li>
<li>递推中滚动数组的应用</li>
</ul>
<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210319175422751.png" alt="image-20210319175422751"></p>
<p><strong>分析</strong>：<br>回溯法可以用来解决此问题，但是当n特别大时其速度让人难以忍受。<br><strong>抽象</strong>：把当前位置(i, j) 看作一种状态，然后定义状态的指标函数<code>d(i, j)</code>为从格子(i, j) 出发，能得到的最大和。在这个状态的定义下，答案为<code>d(1, 1)</code>。<br><strong>状态转移方程</strong>：从格子<code>(i, j)</code>出发有两种方案：往左走或者往右走。由于可以没有限制的在两个决策中做决定，所以应选择指标函数较大的那个。</p>
<script type="math/tex; mode=display">d(i, j) = a(i, j) + max{d(i+1, j), d(i+1, j+1)}</script><p><strong>最优子结构</strong>：全局最优解包含局部最优解。</p>
<p><strong>记忆化搜索与递推</strong>：<br>计算方法1：使用递归(需要注意边界处理)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i][j] + (i == n ? max(solve(i+<span class="number">1</span>, j), solve(i+<span class="number">1</span>, j+<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的方法是正确的但是时间效率太低，其原因在于重复计算。</p>
<p>计算方法2：递推计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    dp[n][j] = a[n][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        d[i][j] = a[i][j] + max(d[i+<span class="number">1</span>][j], d[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算方法3：记忆化搜索</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[i][j] ＞= <span class="number">0</span>) <span class="keyword">return</span> d[i][j];</span><br><span class="line">    <span class="keyword">return</span> d[i][j] = a[i][j] ＋ (i == n ? <span class="number">0</span> : max(solve(i＋<span class="number">1</span>,j),solve(i＋<span class="number">1</span>,j＋<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>千万不要忘记在计算之后把它保存在d[i][j]中。根据C语言“赋值语句本身有返回值”的规定，可以把保存d[i][j]的工作合并到函数的返回语句中。<br>上述程序的方法称为记忆化（memoization），它虽然不像递推法那样显式地指明了计算顺序，但仍然可以保证每个结点只访问一次可以用记忆化搜索的方法计算状态转移方程。当采用记忆化搜索时，不必事先确定各状态的计算顺序，但需要记录每个状态是否已经计算过。</p>
<h3 id="多阶段决策问题"><a href="#多阶段决策问题" class="headerlink" title="多阶段决策问题"></a>多阶段决策问题</h3><h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/image-20210320113319787.png" alt="image-20210320113319787"></p>
<p><strong>分析</strong>：只凭“剩余体积”这个状态已经无法得知每个物品是否已经用过。<br>使用$d(i, j)$表示当前在第i层，背包容量为j的最优决策即最大重量和，状态转移方程为：</p>
<script type="math/tex; mode=display">d(i, j) =</script><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="MC生存买东西"><a href="#MC生存买东西" class="headerlink" title="MC生存买东西"></a>MC生存买东西</h4><p><strong>题目描述</strong>：<br>一个人的背包有21格。<br>一开始他的背包里有m件不同的物品（不能卖）。<br>他要卖n种物品，每种物品有ai件,价值bi,一格可以放ci个，<br>名字sti（0&lt;sti的长度&lt;100)<br>相同的物品可以放同一格(只要没放满）。<br>问他跑一次最多能卖多少钱。</p>
<p><strong>输入格式</strong>：<br>第一行：m,n;<br>下面n行：ai, bi, ci, sti.</p>
<p><strong>输出格式</strong>:<br>最多能买的钱</p>
<p><strong>问题分析</strong>：<br>简化为01背包问题，预期不同的时当取某一个物品时我们可以选择其个数，<br>i, j分别表示i个格子，z种商品<br>d(i, j) 表示这i个格子和前i种商品可以卖的最多钱数<br>d(i, j) = max(d(i , j-1), d(i - w, j))<br>当提供前z种商品时其当前最大价值不选取这种商品仍用前j-1种商品创造的最大价值与选用了这种商品选用w个格子占用的最大价值，其中w需要进行遍历</p>
<p><strong>code</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001    <span class="comment">//N </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXV 101     <span class="comment">//V </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> capacity 21  <span class="comment">//背包容量 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, V, cnt;</span><br><span class="line"><span class="keyword">int</span> s[MAXN], c[MAXN], v[MAXN];   <span class="comment">//s为数量，c为价值，v为多少个为一格 </span></span><br><span class="line"><span class="keyword">int</span> f[MAXV];                     <span class="comment">//占i格的最大价值f[i] </span></span><br><span class="line"><span class="built_in">string</span> name[MAXN];               <span class="comment">//物品的名称 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">upv</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span> </span>&#123;   <span class="comment">//空间向上取整：有a个，一格最多放x个，返回占多少格 </span></span><br><span class="line">    <span class="keyword">int</span> r = x; </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= a) <span class="keyword">return</span> r/x;</span><br><span class="line">        r += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    V = capacity - m;  <span class="comment">//还剩几格 </span></span><br><span class="line">    cnt = <span class="number">1</span>;           <span class="comment">//记录合并后的物品总数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[cnt] &gt;&gt; c[cnt] &gt;&gt; v[cnt] &gt;&gt; name[cnt];</span><br><span class="line">        <span class="comment">/*以下是合并同种物品 */</span> </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i<span class="number">-1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(name[j] == name[i]) &#123;</span><br><span class="line">                s[j] += s[i];</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt --;    </span><br><span class="line">    <span class="comment">/*多重背包模版*/</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=s[i]; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = upv(k, v[i]); <span class="comment">//单独处理占的格子 </span></span><br><span class="line">                <span class="keyword">if</span>(j - w &lt; <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">//格子不够 </span></span><br><span class="line">                f[j] = max(f[j], f[j-w] + c[i] * k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int k  = l + rand() % (r-l+1);</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= r; i+= <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    srand(a[k], a[l]);</span><br><span class="line">    <span class="keyword">while</span>(a[i] &lt;= a[<span class="number">1</span>]) i++;</span><br><span class="line">    <span class="keyword">while</span>(a[j] &gt;= a[i]) j--;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; j )</span><br><span class="line">        swap(a[l], a[i]);</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> == k)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> &lt; k)</span><br><span class="line">        select(a, l, i<span class="number">-1</span>, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        select(a, i+<span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性选择时间选择</span></span><br><span class="line"><span class="comment">/*****</span></span><br><span class="line"><span class="comment">每次划分保证每次选择两区间的长度都大于某个常数</span></span><br><span class="line"><span class="comment">对于一个很大的数组如何选择k和a[0]进行交换保证长度大于某个常数</span></span><br><span class="line"><span class="comment">比方说：2 3 5 8 6 2 3 10 7 9 8 4 12</span></span><br><span class="line"><span class="comment">将其分为三组分别取中位数 5 7 8</span></span><br><span class="line"><span class="comment">将n个元素分组每组分为5个元素，将每组进行排序，求出其中的中位数，再将这n/5个中位数进行排序求出其中位数，如果为偶数个则选取较大的，以这个数为基准</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>
<h2 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h2><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>我们接触过很多排序算法，但大部分都不怎么用得上（尤其是那些$O(n^{2})$的算法，<strong>快速排序</strong>和<strong>归并排序</strong>基本上已经够用了，他们的平均时间复杂度都是$O(nlogn)$。实际上，学术上已经证明了，任何<strong>基于比较的排序算法</strong>的时间复杂度都不能比这更优了。即只任意给出偏序关系，那不可能存在小于$O(n log n)$的排序算法。</p>
<h3 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h3><p>定义：给定线性序集中n个元素和一个整数k，找出这n个元素中第k小的元素。</p>
<ol>
<li><p>在某些特殊情况下，很容易设计出解选择问题的线性时间算法。如：当要选择最大元素或最小元素时，显然可以在O(n)时间完成。（一趟比较即可）</p>
</li>
<li><p>一般的选择问题，特别是中位数的选择问题似乎比最小（大）元素要难。但实际上，从渐近阶的意义上，它们是一样的。也可以在O(n)时间完成。</p>
</li>
</ol>
<p><strong>算法</strong>：</p>
<ol>
<li><p>将n个输入元素划分成n/5（向上取整）个组，每组5个元素，最多只可能有一个组不是5个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共n/5（向上取整）个。</p>
</li>
<li><p>递归调用select来找出这n/5（向上取整）个元素的中位数。如果n/5（向上取整）是偶数，就找它的2个中位数中较大的一个。以这个元素作为划分基准。</p>
</li>
</ol>
<p><strong>注意</strong>：</p>
<ol>
<li><p>设中位数的中位数为x，则比x小和比x大的至少有3*(n-5)/10个：3表示中位数比x小的每一组中有3个元素比x小， n/5-1表示有5个数的数组， 1/2表示大概有1/2的数组的中位数比x小</p>
</li>
<li><p>当$n&gt;=75$时。$3*(n-5)/10 &gt;= n/4$，所以按此基准划分所得的2个子数组的长度都至少缩短$1/4$，也就为原长的$3/4$</p>
</li>
</ol>
<p><strong>code</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> i1, j, l1, j1, m = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int k  = l + rand() % (r-l+1);</span></span><br><span class="line">    <span class="comment">//分组冒泡排序并找到中位数将其置于数组之首</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;=r; i+=<span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i1 = i; i1 &lt; i+<span class="number">5</span>; i1++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j1 = i+<span class="number">1</span>; j1&lt;i+<span class="number">5</span>; j1++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i1] &gt; a[j1]) &#123;</span><br><span class="line">                    swap(a[i1], a[j1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将各分小组的中位数置于队首</span></span><br><span class="line">        swap(a[m++], a[j1]);</span><br><span class="line">    &#125;</span><br><span class="line">    k = select(a, <span class="number">1</span>, m<span class="number">-1</span>, (m<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(a[i] &lt;= a[<span class="number">1</span>]) i++;</span><br><span class="line">    <span class="keyword">while</span>(a[j] &gt;= a[i]) j--;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; j )</span><br><span class="line">        swap(a[l], a[i]);</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> == k)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> &lt; k)</span><br><span class="line">        select(a, l, i<span class="number">-1</span>, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        select(a, i+<span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>求解一个复杂问题，可以将其分解成若干个子问题，子问题可以进一步分解为更小的问题，直到所得的小问题可以分解为基本问题，并且其求解方法是已知的，可以直接求解为止。<br>分治法是一种设计算法策略，要求分解所得的子问题是同类问题，并且原问题的解可以通过组合子问题的解来获取。</p>
<h3 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h3><p>分治法的思想就是：分而治之。一个问题能够用分解法的要素为：</p>
<ul>
<li>问题能够分解为相对规模较小、相互独立且与原问题类型相同的子问题</li>
<li>子问题足够小时可以直接求解</li>
<li>能够将子问题的解组合为原问题的解</li>
<li>由于分治法要求分解同类子问题，并允许不断分解，使问题规模逐渐减小，最终可以用已知的方法求解足够小的子问题故其很自然的就要使用<strong>递归算法</strong>。</li>
</ul>
<p><strong>分治策略的控制抽象</strong>；</p>
<ul>
<li>分治法：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SolutionType <span class="title">DandC</span><span class="params">(ProblemType P)</span> </span>&#123;</span><br><span class="line">    ProblemType P1, P2, P3, Pk;</span><br><span class="line">    <span class="keyword">if</span>(Small(P)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> S(P);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Divide(P, P1, P2, P3, Pk);</span><br><span class="line">        <span class="keyword">return</span> Combine(DandC(P1), DandC(P2), DandC(Pk));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Small()为一个布尔类型的函数判断P是否足够小</span></span><br><span class="line"><span class="comment">//Combine()函数将各子问题的解组合成原始问题的解</span></span><br><span class="line"><span class="comment">//Divide()函数以某种形式将问题P分解’</span></span><br><span class="line"><span class="comment">//S()函数针对足够小的问题进行求解</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一分为二的分治法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SolutionType <span class="title">DandC</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Small(left, right))</span><br><span class="line">        <span class="keyword">return</span> S(left, right);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> m = Divide(left, right);</span><br><span class="line">        <span class="keyword">return</span> Combine(DandC(left, m), DandC(m + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求最大最小元"><a href="#求最大最小元" class="headerlink" title="求最大最小元"></a>求最大最小元</h3><p><em>运用分治法在一个元素集合中寻找最大元和最小元问题。</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::MaxMin(<span class="keyword">int</span> i, <span class="keyword">int</span> j, T&amp; max, T&amp; min) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前置条件：i和j,0 &lt;= i &lt;= j &lt; 表长，是表的下界范围</span></span><br><span class="line">    T min1, max1;</span><br><span class="line">    <span class="keyword">if</span>(i == j) max = min = l[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == j - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i] &lt; l[j]) &#123;</span><br><span class="line">            max = l[j];</span><br><span class="line">            min = l[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            max = l[i];</span><br><span class="line">            min = l[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span>  m = (i+j) / <span class="number">2</span>;</span><br><span class="line">        MaxMin(i, m, max, min);</span><br><span class="line">        MaxMin(m+<span class="number">1</span>, j, max1, min1);</span><br><span class="line">        <span class="keyword">if</span>(max &lt; max1) max = max1;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; min1) min = min1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">子问题：各个分组求最大最小</span></span><br><span class="line"><span class="comment">Combine：将各个分组的的最大最小进行比较</span></span><br><span class="line"><span class="comment">足够小：i == j 或着 i = j - 1</span></span><br><span class="line"><span class="comment">*****/</span></span><br></pre></td></tr></table></figure>
<h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p><em>在表中搜索确定一个关键字值为给定的元素是一种是一种常见的运算。</em></p>
<h4 id="用分治法求解"><a href="#用分治法求解" class="headerlink" title="用分治法求解"></a>用分治法求解</h4><p>有一个长度为n的有序表，要求在表中搜索与给定元素x有相同关键字值的元素。若n=0，搜索失败；若n&gt;0，则可将有序表分解成若干个子表。最简单的做法是分解成两个子表。假定以元素$a_{m}$为划分点。则将其与给定元素x进行比较。比较结果有三种情况：</p>
<ul>
<li>x &lt; $a_{m}$，在前半部分子表中寻找</li>
<li>x = $a_{m}$，搜索成功</li>
<li>x &gt; $a_{m}$，在后半部分子表中搜索</li>
</ul>
<p>二分搜索框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SortableList&lt;T&gt;::BSearch(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> left, <span class="keyword">int</span> right) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = Divide(left, right);</span><br><span class="line">        <span class="keyword">if</span>(x &lt; l[m) <span class="keyword">return</span> BSearch(x, left, m<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; l[m]) <span class="keyword">return</span> BSearch(x, m+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对半搜索"><a href="#对半搜索" class="headerlink" title="对半搜索"></a>对半搜索</h4><p>对半搜索是一种二分搜索。<br>设当前搜索子表为：$a_{left},……,a_{right}$，令</p>
<script type="math/tex; mode=display">m = (left + right) / 2</script><p>这种二分搜索被称为对半搜索，将表划分成几乎等大小的两个子表</p>
<p><strong>对半搜索递归算法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SortableList&lt;T&gt;::BSearch(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> left, <span class="keyword">int</span> right) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; l[m])</span><br><span class="line">            <span class="keyword">return</span> BSearch(x, left, m<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; l[m])</span><br><span class="line">            <span class="keyword">return</span> BSearch(x, m+<span class="number">1</span>, right)；</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定理</strong>：对于$n \geq 0$，对半搜索递归函数是正确的。</p>
<p><strong>对半搜索的迭代算法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SortacleList&lt;T&gt;::BSearch(<span class="keyword">const</span> T&amp; x)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> m, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        m = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; l[m])</span><br><span class="line">            right = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; l[m])</span><br><span class="line">            left = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉判定树"><a href="#二叉判定树" class="headerlink" title="二叉判定树"></a>二叉判定树</h4><p><em>二分搜索时的算法行为可以用一棵二叉树来描述。</em><br>我们称这棵描述搜索算法执行过程的二叉树为<strong>二叉判定树</strong>。<br><em>略</em></p>
<h3 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h3><p><strong>排序</strong>又称为分类。<br>分治法求解排序问题的思想很简单：按某种方式将序列分成两个或多个子序列，再将已排序的子序列合并成一个有序序列即可。<br><strong>合并排序</strong>和<strong>快速排序</strong>是两种典型的符合分治策略的排序算法。</p>
<h4 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h4><p><em>merge sort 的基本运算就是把两个或者多个有序序列合并成一个有序序列，下面介绍最基本的合并算法；两路合并运算：</em></p>
<ul>
<li>合并两个有序序列<br>实现这种合并的方法十分简单：比较两个有序序列的最小值，输出其中较小者，然后重复此过程，直到其中一个序列为空，如果另一个还有元素未输出则将剩余依次输出即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::Merge(<span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    T* temp = <span class="keyword">new</span> T[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((i &lt;= mid) &amp;&amp; (j &lt;= right))&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i] &lt;= l[j])</span><br><span class="line">            temp[k++] = l[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++] = l[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        temp[k++] = l[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right)</span><br><span class="line">        temp[k++] = l[j++];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, k = left;l&lt;= right;)</span><br><span class="line">        l[k++] = temo[i++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>分治法求解<br>算法描述：将待排序的元素序列一分为二，得到两个长度基本相等的子序列，类似对半搜索的做法：然后最两个子序列分别排序，如果子序列较长，还可以继续细分，直到子序列的长度不超过1为止；当分解所得的子序列已排列有序时，可以采用上面的方法进行合并，实现将子问题的解组成成原问题的解。<br>分治法审视问题的视角：元素一分为二，分别进行排序，当序列为空或只有一个元素时别人为子问题足够小以至于可以直接解决。</p>
</li>
<li><p>合并排序算法</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::MerageSort()</span><br><span class="line">&#123;</span><br><span class="line">    MergeSort(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::MerageSort(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        MerageSort(left, mid);</span><br><span class="line">        MerageSort(mid+<span class="number">1</span>, right);</span><br><span class="line">        Merge(left, mid, left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><em>quick sort 又被称为 分划交换排序。</em><br>采用一种特殊的分划操作对排序问题进行求解，其分解方法为：</p>
<ol>
<li>在待排序的序列中($K_0, K_1,…K_{n-1}$)中选择一个元素作为<strong>分划元素</strong>，即<strong>主元</strong>。</li>
<li>不妨假定$K_a$为主元，经过一趟特殊的分划处理将原序列中的元素重新排列，值得以主元为轴心，将序列分为左右两个子序列。</li>
<li>使得主元左侧子序列中所有的元素都不大于主元，右侧都不小于。</li>
<li>在新的序列中$K_a$处于位置$j$处，则新序列应满足上述条件。这样新序列就被分为了三部分：主元和左右两个子序列。&lt;/br&gt;$(K_0,…K_{j-1})K_j(K_{j+1},…,K_{n-1})$</li>
</ol>
<p><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/QuickSort2.png" alt="QuickSort2"><br><strong>分划</strong>：以主元为轴心，对一个序列按上述要求重新排列，并分解为两个子序列的国车过。<br><strong>实质</strong>：分划就是对原序列排序问题分解成两个待解决的、性质相同的子问题。</p>
<p>快速排序中，使用分划操作将一个问题分解成两个相互独立的子问题。当子序列为一个元素或为空序列时我们认为其足够小。无需进行任何处理。<br>分治法要求分别求解子问题后，设法将子问题的解组合成原问题的解，这一点在快速排序下变得非常简单：由于划分操作，左边序列均不大于主元，右边序列均不小于主元。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">合并排序</th>
<th style="text-align:center">快速排序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">分治策略</td>
<td style="text-align:center">分治策略}</td>
</tr>
<tr>
<td style="text-align:center">问题分解简单：一分为二</td>
<td style="text-align:center">问题分解困难：分化操作</td>
</tr>
<tr>
<td style="text-align:center">子问题解合并原问题解较难</td>
<td style="text-align:center">子问题解合并原问题相对简单</td>
</tr>
</tbody>
</table>
</div>
<p><strong>分划操作</strong>：<br><em>快速排序的核心。</em><br>每趟划分选择序列中哪个元素是需要考虑的，最简单的做法就是选择序列中的第一个元素。<br><img src="/2021/03/05/%E8%93%9D%E6%A1%A5%E6%9D%AF/quick_sort_partition_animation.gif" alt="quick_sort_partition_animation"><br><em>注:此图为以末尾元素为主元</em><br>算法要求在待排序序列尾部设置一个大值$\infty$作为哨兵防止指针右移过程中移出序列之外，不能终止。这种情况当初始序列以递减次序列排序时就会发生。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SortableList&lt;T&gt;::Partition(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;<span class="comment">//前置条件：left &lt;= right</span></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(l[i] &lt; l[left])；</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">while</span>(l[j] &gt; l[left]);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            Swap(i,j); <span class="comment">//交换两个元素l[i] 和 l[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i &lt; j);</span><br><span class="line">    Swap(left, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>快速排序算法<br>调用分划函数，以主元为轴心分成两个子序列。然后分别用递归调用自身对这两个子序列实施快速排序，将他们排成有序序列。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::QuickSort()&#123;</span><br><span class="line">    QuickSort(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SortableList&lt;T&gt;::QuickSort(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = Partition(left, right);</span><br><span class="line">        QuickSort(left, j<span class="number">-1</span>);</span><br><span class="line">        QuickSort(j+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>改善快速排序算法</li>
</ul>
<ol>
<li>改进主元选取方法：一是选取$K_{(left+right)/2}$、二是选取$left ~ right$间的随机整数、三是选取$K_{left}$、$K_{(left+right)/2}$和$K_{right}$中的一个。</li>
<li>快速排序中子序列会变得越来越小，当子序列的长度小到一定程度时，快速排序的速度反而不如一些简单的排序，如直接插入法。</li>
<li>递归算法的效率往往不如非递归算法，可以设计非递归的排序算法：使用一个堆栈，在一次分划操作后，将其中一个子序列范围的上下界进栈保存，而对另一个序列继续进行分划排序。当对此子序列排序时，仍将分划的到的一个子序列的上下界进栈保存，对另一个子序列继续进行排序。直到足够小为止，再从栈中取出保存的某个尚未排序的子序列上下界，对该子序列进行快速排序。</li>
</ol>
<h3 id="选择问题"><a href="#选择问题" class="headerlink" title="选择问题"></a>选择问题</h3><h3 id="斯特拉森矩阵乘法"><a href="#斯特拉森矩阵乘法" class="headerlink" title="斯特拉森矩阵乘法"></a>斯特拉森矩阵乘法</h3>]]></content>
  </entry>
  <entry>
    <title>vscode使用指南</title>
    <url>/2021/03/05/vscode%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>基于CNN+BiSLTM+CTC的智能发票识别系统</title>
    <url>/2021/03/12/%E5%9F%BA%E4%BA%8ECNN-BiSLTM-CTC%E7%9A%84%E6%99%BA%E8%83%BD%E5%8F%91%E7%A5%A8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="CNN-卷积神经网络"><a href="#CNN-卷积神经网络" class="headerlink" title="CNN 卷积神经网络"></a>CNN 卷积神经网络</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><p><strong>Convolutional Neural Network</strong> 是一种前馈神经网络，它的神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色的表现。</p>
<p>与普通神经网络非常相似，他们都具有可学习的权重和偏置常量(biases)的神经元组成。每个神经元都接受一些输入，并做一些点积计算，输出是每个分类的分数，普通神经网络里的一些计算技巧在这里依然适用。</p>
<p><strong>不同的是</strong>：卷积神经网络输入的是图像，可以让我们把特定的性质编码入网络结构，使我们的前馈函数更加有效率，并减少了大量参数。</p>
<h3 id="具有三维体积的神经元-3D-volumes-of-neurons"><a href="#具有三维体积的神经元-3D-volumes-of-neurons" class="headerlink" title="具有三维体积的神经元 (3D volumes of neurons)"></a>具有三维体积的神经元 (3D volumes of neurons)</h3><p>卷积神经网络利用输入是图片的特点，将神经元设计成三个维度：<strong>width</strong>, <strong>height</strong>, <strong>depth</strong>(注意：这里的depth不是指神经元的深度，而是用来描述神经元的)。比如输入的大小是32x32x3(rgb)，那么输入的神经元也就具有32x32x3的维度。   </p>
<h1 id="BiSLTM"><a href="#BiSLTM" class="headerlink" title="BiSLTM"></a>BiSLTM</h1><h1 id="CTC"><a href="#CTC" class="headerlink" title="CTC"></a>CTC</h1>]]></content>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
</search>
